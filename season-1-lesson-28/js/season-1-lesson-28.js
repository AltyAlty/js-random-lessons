/*Если в конструкторе был указан какой-то метод, то объекты, созданные
при помощи это конструктора, скопируют в себя всю реализацию этого метода.
При большом количестве объектов это может быть лишним, так как несколько
объектов будут содержать повторяющийся код. Любая функция в JS имеет свойство
"prototype". Это свойство обычно используется с функциями-конструкторами.
Чтобы избежать ситуацию, описанную в начале, методы конструктора нужно
отдельно указывать при помощи этого свойства "prototype". В таком случае
у созданных объектов уже не будет методов их конструктора, но эти объекты
смогут пользоваться этими метода, используя их из прототипа конструктора
благодаря замыканию. То есть полученные объекты будут иметь ссылку на 
прототип конструктора.*/

function Car(name) {
    this.name = name;
    this.isTurnedOn = false;
    this.speed = 0;

    this.engine = {
        v: 1,
        horses: 100,
        isTurnedOn: false
    };    
};

Car.prototype.start = function () {
    this.isTurnedOn = true;
    this.speed = 50;
    this.engine.isTurnedOn = true;
    console.log(this.name + ' ' + this.speed);    
};

var car1 = new Car('kek');
car1.start();

var car2 = new Car('lol');
car2.start();

console.log('--------------------------------------------------------------------------------');

/*--------------------------------------------------------------------------------*/

/*Если в конструкторе не указать какое-то свойство и метод, в котором 
это свойство создается, а в прототипе указать как метод, так и это 
свойство, то после создания объекта на основе этого конструктора 
этот объект не будет иметь этого свойства, но это свойство будет 
в прототипе. И если затем попытаться прочитать это свойство у этого 
объекта, например, при помощи "console.log()", то внутри этого объекта 
свойство найдено не будет, но будет найдено в прототипе. А дальше если 
вызвать упомянутый ранее метод от лица этого созданного объекта, то уже 
будет создано новое свойство для этого объекта.*/

function Car2(name) {
    this.name = name;       
};

Car2.prototype.speed = 0;

Car2.prototype.changeSpeed = function () {
    this.speed = 5;    
};

var car3 = new Car2('lel');
console.log(car3.speed); /*0, берется из прототипа.*/
car3.changeSpeed(); /*Поскольку в контексте объекта "car3" нет свойства "speed", то 
оно там будет создано.*/
console.log(car3.speed); /*5, берется уже из объекта поскольку в контексте 
объекта "car3" уже есть свойство "speed".*/

console.log('--------------------------------------------------------------------------------');

/*--------------------------------------------------------------------------------*/

/*Если в конструкторе не указать какое-то свойство и метод, в котором 
это свойство создается в виде объекта, а в прототипе указать как метод, 
так и это свойство, то после создания объекта на основе этого 
конструктора этот объект не будет иметь этого свойства, но это свойство 
будет в прототипе. И если затем попытаться прочитать это свойство у этого 
объекта, например, при помощи "console.log()", то внутри этого объекта 
свойство найдено не будет, но будет найдено в прототипе. А дальше если 
вызвать упомянутый ранее метод от лица этого созданного объекта, то не 
будет создано нового свойство для этого объекта, а будет изменено 
свойство в прототипе. Так происходит потому, что объекты это ссылочные 
типы данных, и потому, что все созданные объекты при помощи какого-то 
конструктора ссылаются на один и тот же объект прототипа своего 
конструктора. Исходя из этого лучше избегать указывать свойства в 
прототипах, лучше делать такое только для методов.*/

function Car3(name) {
    this.name = name;       
};

Car3.prototype.engine = {
    speed: 10
};

Car3.prototype.changeSpeed = function () {
    this.engine.speed = 20;
    console.log(this.engine.speed);
};

var car4 = new Car3('kuk');
console.log(car4.engine.speed); /*10, из прототипа.*/
car4.changeSpeed(); /*20, изменилось значение в прототипе.*/

var car5 = new Car3('lal');
console.log(car5.engine.speed); /*20, из прототипа.*/
car5.changeSpeed(); /*20, снова изменилось значение в прототипе.*/