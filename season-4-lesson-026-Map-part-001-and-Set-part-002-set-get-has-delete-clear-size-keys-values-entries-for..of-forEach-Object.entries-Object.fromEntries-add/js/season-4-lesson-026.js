'use strict';

/*-------------------------------------------------------------------------------------------------------------------*/

/*Объекты нужны для хранения именованных коллекций. Массивы нужны для хранения упорядоченных коллекций.*/

/*Map это коллекция ключ/значение, как и Object, но Map позволяет использовать ключи любого типа.*/

/*Методы и свойства Map:
1) "new Map()" – создает коллекцию.
2) "map.set(key, value)"" – записывает по ключу "key" значение "value".
3) "map.get(key)" – возвращает значение по ключу или undefined, если ключ "key" отсутствует.
4) "map.has(key)" – возвращает true, если ключ "key" присутствует в коллекции, иначе false.
5) "map.delete(key)" – удаляет элемент (пару ключ/значение) по ключу "key".
6) "map.clear()" – очищает коллекцию от всех элементов.
7) "map.size" – возвращает текущее количество элементов.*/
let map1 = new Map();

map1.set('1', 'str1');
map1.set(1, 'num1');
map1.set(true, 'bool1');
console.log(map1); // Map(3) { '1' → "str1", 1 → "num1", true → "bool1" }
console.log(map1.size); // 3
console.log(map1.get('1')); // 'str1'
console.log(map1.get(1)); // 'num1' 

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы получить или установить какое-то значение в Map можно использовать "[]", но в этом случае Map рассматривался 
бы как обычный объект, таким образом это приводит ко всем соответствующим ограничениям (только строки/символьные ключи 
и так далее). Поэтому лучше использовать методы "get", "set" и так далее.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Map может использовать объекты в качестве ключей.*/
let obj1 = { a: 1 };
let map2 = new Map();
map2.set(obj1, 2);
console.log(map2.get(obj1)); // 2

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы сравнивать ключи, объект Map использует алгоритм "SameValueZero". Это почти такое же сравнение, что и ===, с 
той лишь разницей, что NaN считается равным NaN. Так что NaN также может использоваться в качестве ключа. Этот 
алгоритм не может быть заменен или модифицирован.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*При использовании Map можно использовать цепочку вызовов.*/
let map3 = new Map();

map3.set(1, 1)
    .set(2, 2)
    .set(3, 3);

console.log(map3); // Map(3) { 1 → 1, 2 → 2, 3 → 3 }

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Для перебора коллекции Map есть 3 метода:
1) "map.keys()" – возвращает итерируемый объект по ключам.
2) "map.values()" – возвращает итерируемый объект по значениям.
3) "map.entries()" – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по 
умолчанию в цикле "for..of".*/

/*В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление 
элементов. При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для 
инициализации.*/
let map4 = new Map([
    ['a', 1],
    ['b', 2],
    ['c', 3]
]);

// map4.set('a', 1);
// map4.set('b', 2);
// map4.set('c', 3);

console.log(map4); // Map(3) { a → 1, b → 2, c → 3 }

for (const k of map4.keys()) {
    console.log(k); // 'a' => 'b' => 'c'
};

for (const v of map4.values()) {
    console.log(v); // 1 => 2 => 3
};

for (const e of map4.entries()) {
    console.log(e); // Array [ "a", 1 ] => Array [ "b", 2 ] => Array [ "c", 3 ]
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Map имеет встроенный метод "forEach()", схожий со встроенным методом массивов. Функция внутри метода "forEach()"
может принимать до трех параметров: значение по ключу, сам ключ и весь Map.*/
let map5 = new Map();
map5.set('a', 1);
map5.set('b', 2);
map5.set('c', 3);

map5.forEach((value, key, map) => {
    console.log(value);
    console.log(key);
    console.log(map);
});

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы из обычного объекта получить Map, можно использовать метод "Object.entries()". Метод "Object.entries()" 
возвращает массив массивов пар ключ-значение.*/
let obj2 = { a: 1, b: 2, c: 3 };
console.log(Object.entries(obj2));
let map6 = new Map(Object.entries(obj2));
console.log(map6); // Map(3) { a → 1, b → 2, c → 3 }

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Чтобы из Map получить объект, можно использовать метод "Object.fromEntries()". Метод "Object.fromEntries()" 
возвращает объект из массива массивов пар ключ-значение.*/

let obj3 = Object.fromEntries([
    ['a', 1],
    ['b', 2],
    ['c', 3]
]);

console.log(obj3); // Object { a: 1, b: 2, c: 3 }

let map7 = new Map([
    ['a', 1],
    ['b', 2],
    ['c', 3]
]);

let obj4 = Object.fromEntries(map7.entries());
console.log(obj4); // Object { a: 1, b: 2, c: 3 }

/*Можно написать и так, поскольку метод "Object.fromEntries()" ожидает перебираемый объект в качестве аргумента, не 
обязательно массив. А перебор Map как раз возвращает пары ключ/значение, так же, как и "map.entries()".*/
let obj5 = Object.fromEntries(map7);
console.log(obj5); // Object { a: 1, b: 2, c: 3 }

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Объект Set – это особый вид коллекции. Это "множество" значений (без ключей), где каждое значение может появляться 
только один раз. Set лучше массивов при поиске значений. Set ищет у себя значения, используя хэш-таблицы. Множество 
Set лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность, когда при использовании массивов
необходимо пройти по всем элементам.*/

/*Методы Set:
1) "new Set(iterable)" – создает Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это 
массив), то копирует его значения в новый Set.
2) "set.add(value)" – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
3) "set.delete(value)" – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
4) "set.has(value)" – возвращает true, если значение присутствует в множестве, иначе false.
5) "set.clear()" – удаляет все имеющиеся значения.
6) "set.size" – возвращает количество элементов в множестве.*/
let set1 = new Set();
let obj6 = { a: 1 };
let obj7 = { b: 2 };
let obj8 = { c: 3 };
set1.add(obj6);
set1.add(obj7);
set1.add(obj8);
set1.add(obj6);
set1.add(obj7);
console.log(set1.size); // 3
console.log(set1); // Set(3) [ {…}, {…}, {…} ]

for (const value of set1) {
    console.log(value); // { a: 1 } => { b: 2 } => { c: 3 }
};

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Set можно перебрать как циклом "for..of", так и методом "forEach()". Функция внутри метода "forEach()" принимает до
трех параметров: значение, еще раз это значение и весь Set. Три параметра здесь сделано ради совместимости с объектом
Map, чтобы если что можно было поменять Set на Map.*/
let set2 = new Set([
    ['a', 1],
    ['b', 2],
    ['c', 3]
]);

set2.forEach((value, valueAgain, set) => {
    console.log(value); // [ "a", 1 ] => [ "b", 2 ] => [ "c", 3 ]
    console.log(valueAgain); // [ "a", 1 ] => [ "b", 2 ] => [ "c", 3 ]
    console.log(set); // Set(3) [ (2) […], (2) […], (2) […] ]
});

console.log('--------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Set имеет те же встроенные методы, что и Map:
1) "set.values()" – возвращает перебираемый объект для значений.
2) "set.keys()" – то же самое, что и "set.values()", присутствует для обратной совместимости с Map.
3) "set.entries()" – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной 
совместимости с Map.*/
let set3 = new Set([
    ['a', 1],
    ['b', 2],
    ['c', 3]
]);

for (const v of set3.values()) {
    console.log(v); // [ "a", 1 ] => [ "b", 2 ] => [ "c", 3 ]
};

for (const k of set3.keys()) {
    console.log(k); // [ "a", 1 ] => [ "b", 2 ] => [ "c", 3 ]
};

for (const e of set3.entries()) {
    console.log(e); // Array [ [ "a", 1 ] [ "a", 1 ] ] => Array [ [ "b", 2 ] [ "b", 2 ] ] => Array [ [ "c", 3 ] [ "c", 3 ] ]
};