/*Эта строка определяет, что код должен выполняться в "строгом режиме". В строгом режиме нельзя, например, использовать
необъявленные переменные.*/
// "use strict";

/*-------------------------------------------------------------------------------------------------------------------*/

let a = {};
let b = { d: 0 };
let c = { e: 1 };

a[b] = 4;
a[c] = 5;

/*Когда мы у какого-либо объекта устанавливаем новое свойство, то JS неявно применяет метод "stringify()" к значению
этого свойства. Поскольку "b" и "c" объекты, то они оба конвертируются в строку "[object Object]". Так как имена свойств
"a[b]" и "a[c]" будут равны, то получится, что мы присвоим сначало одно, потом другое значение одному и тому же свойству
"[object Object]".*/
console.log(a[b]); // 5
console.log(a);

/*-------------------------------------------------------------------------------------------------------------------*/

/*При обращении к несуществующему месту в глобальном объекте "window" мы получим не "undefined", а ошибку, так как такое
место не определено.*/
// console.log(ddd); // Uncaught ReferenceError: ddd is not defined
// console.log(ddd.a); // Uncaught ReferenceError: ddd is not defined

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы попробуем прочитать переменную, которую только объявили, но не задали ей значения, то получим "undefined".*/
let d;
console.log(d); // undefined

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы где-либо создадим новую переменную, не используя "var", "let" или "const", и при этом зададим значение этой
переменной, то такая переменная будет создана на самом верхнем уровне программы.*/
e = 0;
console.log(e); // 0

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы попробуем прочитать значение переменной, которая инициализирована по коду после места, где мы эту переменную
пытаемся прочитать, то получим разный результат в зависимости от того, как мы инициализировали нашу переменную.*/
console.log(f);
// let f = 1; // Uncaught ReferenceError: can't access lexical declaration 'f' before initialization
// const f = 1; // Uncaught ReferenceError: can't access lexical declaration 'f' before initialization
// f = 1; // Uncaught ReferenceError: f is not defined

/*Все "var" поднимаются как вверх программы, но без указания значений. Это называется "hoisting". Тоже самое происходит
и с объявлениями функций.*/
var f = 1; // undefined

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы несколько раз проинициализируем одну и туже переменную при помощи "var", то мы просто будем менять ее
значение.*/
var h = 2;
console.log(h); // 2
var h = 3;
console.log(h); // 3

/*Если мы несколько раз проинициализируем одну и туже переменную при помощи "let", то мы получим ошибку.*/
let i = 4;
// let i = 5; // Uncaught SyntaxError: redeclaration of let i

/*Если мы несколько раз проинициализируем одну и туже переменную при помощи "const", то мы получим ошибку.*/
const j = 6;
// const j = 7; // Uncaught SyntaxError: redeclaration of const j

/*Если мы несколько раз установим значение одной и той же переменной, не используя "var", "let" или "const", то мы
просто будет менять значение переменной созданной в глобальной области видимости.*/
k = 8;
console.log(k); // 8
k = 9;
console.log(k); // 9

/*-------------------------------------------------------------------------------------------------------------------*/

/*"const" переменные нельзя переприсваивать, но можно менять внутренности у объектов и массивов.*/
const l = { a: 0 };
// l = {}; // Uncaught TypeError: invalid assignment to const 'l' 
l.a = 1;
l.b = 0;
console.log(l); // { a: 1, b: 0 }

const ll = [];
// ll = [1, 2, 3]; // Uncaught TypeError: invalid assignment to const 'll'
ll[0] = 0;
console.log(ll); // [ 0 ]

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы создадим и вызовем функцию, которая указывает значение какой-то переменной, которая раннее не была еще
объявлена, то будет создана такая переменная с указанным значением в глобальной области видимости.*/
function createM() {
    m = 10;
};

createM();

console.log(m); // 10

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы складываем число с "undefined", то получаем "NaN".*/
var p = 11;

console.log(p + q); // NaN

var q = 12;

/*-------------------------------------------------------------------------------------------------------------------*/

console.log('1' + 2); // 12 (string)
console.log(1 + '2'); // 12 (string)
console.log('1' - 2); // -1 (number)
console.log(1 - '2'); // 12 (number)
console.log('1' * 2); // 2 (number)
console.log(1 * '2'); // 2 (number)
console.log('1' / 2); // 0.5 (number)
console.log(1 / '2'); // 0.5 (number)
console.log('1df' * 2); // NaN

/*-------------------------------------------------------------------------------------------------------------------*/

/*Объявляем переменную "r" в глобальной области видимости и устанавливаем ее значение как примитив.*/
var r = 13;

/*Здесь "r" будет внутренним параметром функции и никак не повлияет на "r", созданный в глобальной области видимости.*/
function doSomethingWithROne(r) {
    r = 14;
};

doSomethingWithROne(r);
console.log(r); // 13

/*Здесь же функция сначала попробует найти "r" в своей области видимости, ничего не найдет и пойдет искать на уровень
выше, то есть в глобальную область видимости, и в итоге найдет нашу переменную "r", созданную в этой области видимости.
Соответственно эта функция изменить значение этой переменной.*/
function doSomethingWithRTwo() {
    r = 14;
};

doSomethingWithRTwo(r);
console.log(r); // 14

/*-------------------------------------------------------------------------------------------------------------------*/

/*Объявляем переменную "ы" в глобальной области видимости и устанавливаем ее значение как объект.*/
var s = { a: 0 };

/*Здесь "s" будет внутренним параметром функции и никак не повлияет на "s", созданный в глобальной области видимости.*/
function doSomethingWithSOne(s) {
    s = 15;
};

doSomethingWithSOne(s);
console.log(s); // { a: 0 }

/*Но здесь уже мы сможем поменять свойство в объекте "s", хотя тут тоже функция использует параметр.*/
function doSomethingWithSTwo(s) {
    s.a = 16;
};

doSomethingWithSTwo(s);
console.log(s); // { a: 16 }

/*Здесь же функция сначала попробует найти "s" в своей области видимости, ничего не найдет и пойдет искать на уровень
выше, то есть в глобальную область видимости, и в итоге найдет нашу переменную "s", созданную в этой области видимости.
Соответственно эта функция изменить значение этой переменной.*/
function doSomethingWithSThree() {
    s = 17;
};

doSomethingWithSThree();
console.log(s); // 17

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если не указано обратного, то функция всегда возвращает "undefined".*/
function doSomethingWithV(number) {
    var a = number + 19;
};

let v = doSomethingWithV(19);

console.log(v); // undefined

/*-------------------------------------------------------------------------------------------------------------------*/

let x = 21;

/*Если какой-то функции, находящейся внутри другой функции, нужно найти какую-то переменную, которой нет в ее области
видимости, то она не сразу пойдет искать эту переменную в глобальную область видимости, а сначала пойдет на один уровень
вверх, то в функцию, в которой она содержится, и так далее добираясь до глобальной области видимости.*/
function showX() {
    let x = 22;

    function showXX() {
        console.log(x);
    };

    showXX();
};

showX(); // 22

let y = 23;

/*Здесь поиск остановится в области видимости функции "showY", так в ней будет найден параметр с именем "y".*/
function showY(y) {
    function showYY() {
        console.log(y);
    };

    showYY();
};

showY(24); // 24

/*-------------------------------------------------------------------------------------------------------------------*/

function doTheMagicOne(aaa) {
    console.log(aaa);

    function doTheMagicThree(ccc) {
        return console.log(ccc);
    };

    doTheMagicThree(27);

    return function doTheMagicTwoBTWYouDontNeedToNameIt(bbb) {
        return console.log(bbb);
    };
};

/*Здесь сначала вызовется функция "doTheMagicOne()" с параметром "25", а потом вызовется функция, которая возвращается
функцией "doTheMagicOne()", с параметром "26". Функцию, которая возвращается другой функцией, именовать необязательно.*/
doTheMagicOne(25)(26);

function doTheMagicFour() {
    console.log('Magic Four');

    function doTheMagicFive() {
        console.log('Magic Five');
    };

    return doTheMagicFive;
};

doTheMagicFour()(); // Magic Four => Magic Five