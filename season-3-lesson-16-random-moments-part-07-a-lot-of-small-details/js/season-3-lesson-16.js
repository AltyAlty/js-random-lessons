/*Бразуер не позволит какому-либо сайту прочитать куки от другого сайта.
Куки-файл нужен для общения сервера и клиента. Этот файл может перенаправляться
от сервера до клиента и обратно.*/

/*Для использования протокола "HTTPS" нужен сертификат SSL. Такие сертификаты
могут быть платными и бесплатными.*/

/*GET-запросы должны быть идемпотентные, то есть сколько бы раз мы не сделали
один и тот же GET-запрос, мы должны получить один и тот же ответ. Это означает,
что наши GET-запросы ничего на сервере не меняют. Для изменения данных надо
использовать POST-запрос. POST-запрос в отличии от GET-запроса имеет тело запроса,
в который можно поместить данные для сервера. Но для GET-запроса можно указать
параметры.*/

/*Пароли на сервере должны храниться только в закодированном виде.*/

/*Примеры методов функций: "bind()", "call()", "apply()".*/

/*Хуки используются внутри компоненты, не используются в условиях и циклах.*/

/*"Redux-SAGA" основана на функциях-генераторах.*/

/*Хок "React.memo" используется, чтобы "React" пропускал рендеринг компонента, 
если его props не были изменены. Для классовых компонентов аналагом является
наследование от "React.PureComponent".*/

/*"Babel.JS" - это транспайлер, который преобразует ваш современный JavaScript для 
запуска в старых браузерах (новые стандарты в старый, JSX в JS и так далее). "Babel.JS"
состоит из транспайлера и полифила. Транспайлер переводит, например, JSX в JS.
Полифил позволяет более новым версиям JS работать в старых браузерах.*/

/*Максимальный размер "localStorage" 5 мегабайт.*/

/*"localSotare" и "sessionStorage" хранятся у клиента, только цикл жизни у 
"sessionStorage" ограничен длительностью вкладки страницы.*/

/*Примеры "LIFO": стек.*/

/*Примеры "FIFO": очередь.*/

/*Преимущество самовызывающейся функции в том, что она позволяет создать модульность, то
есть можно создать переменные, которые не попадут во внешнюю область видимости.*/

/*"finally" в конструкции "try-catch-finally" выполняет указанный внутри код независимо
от того, произошла ошибка или нет.*/

/*Метод "Promise.all()" принимает в качестве параметра перечисляемый объект, например, массив,
и возвращает промис, который выполнится тогда, когда будут выполнены все промисы, переданные в 
виде перечисляемого аргумента, или отклонено любое из переданных промисов.

Метод "Promise.all()" возвращает массив значений от всех промисов, которые были ему переданы. 
Возвращаемый массив значений сохраняет порядок оригинального перечисляемого объекта, но не порядок 
выполнения промисов. Если какой-либо элемент перечисляемого объекта не является промисом, то он 
будет преобразован с помощью метода "Promise.resolve".

Если одно из переданных промисов будет отклонено, метод "Promise.all()" будет немедленно 
отклонен со значением отклоненного промиса, не учитывая другие промисы, независимо выполнены они 
или нет. Если в качестве аргумента будет передан пустой массив, то Метод "Promise.all()" будет 
выполнен немедленно.*/

/*Преимущество "async/await" над обычным использованием промисов в том, что уменьшается вложенность
промисов. Код более выглядит как синхронный.*/

/*При создании React-приложения мы импоортируем React в каждый файл, где используем JSX, чтобы
потом при отправке этого JSX в браузер при помощи метода "React.createElement()" преобразовать
этот JSX в нативный JS, так как JSX является по сути синтаксическим сахаром над JS. Но 
"React.createElement()" использовался раньше, поэтому можно не импортировать React в каждый файл.
Сейчас используется JSX-функция, эта функция автоматически при помощи Babel дописывается
импортом: "import {jsx as _jsx} from 'react/jsx-runtime';".*/

/*Разница между "map" и "forEach" в том, что первый возвращает новый массив, а второй
изменяет исходный. Также "forEach" возвращает "undefined", а "map" новый массив.*/

/*PATCH-запрос нужен для того, чтобы изменить свойство в каком-нибудь объекте,
в то время как PUT-запрос заменяет весь объект.*/

/*Ключевое слово "super" создает "this" на расширяемом классе, то есть создатся
"this" родительского класса. В конструкторе дочернего класса ключевое слово "super()" используется 
как функция, вызывающая родительский конструктор. Ее необходимо вызвать до первого обращения к 
ключевому слову "this" в теле конструктора. Ключевое слово "super()" также может быть 
использовано для вызова функций родительского класса.*/

/*Cleanup-функция для "UseEffect" указывается в "return" как callback-функция,
которая будет вызвана в момент, когда компонент будет убит, чтобы
подчистить все побочные эффекты.*/

/*Функция "React.createContext()" возвращает объект контекста, у которого есть свойство
"Provider".*/

/*"FLUX" (концепция) в отличии от "REDUX" (библиотека) подразумевает использовать несколько 
"store" и не имеет "reducers" (имеет свою систему диспатчеризации). Также во "FLUX" может быть 
муттабельные "store".*/

/*Лучше наследоваться от "React.PureComponent", чем "React.component", так как приходящие "props"
будут сравниваться с предыдущми автоматически, когда при наследовании от "React.component" во время 
срабатывания метода жизненного цикла "ShouldComponentUpdate" нам нужно самим указать такую проверку.
Но такое сравнение поверхностоное, порой необходимо писать более глубокую проверку. Для функциональных
компонентов используется "React.Memo".*/

/*Метода жизненного цикла классового компонента:
1. Инициализация
а) constructor()

2. Монтирование
а) static getDerivedStateFromProps()
б) componentWillMount() (устаревший)
в) render()
г) componentDidMount()

3. Обновление
a) componentWillReceiveProps() (устаревший)
б) static getDerivedStateFromProps()
в) shouldComponentUpdate()
г) componentWillUpdate() (устаревший)
д) render()
е) getSnapshotBeforeUpdate()
ж) componentDidUpdate()

4. Размонтирование
а) componentWillUnmount()

5. Обработка ошибок
а) static getDerivedStateFromError()
б) componentDidCatch()*/

/*Фреймворк диктует правила как писать структуру кода, а библиотека нет. Фреймворк можно подключить
один, а библиотек больше одной.*/

/*В React одностороннее направление данных, а в Angular и Vue двустороннее (2-way binding).*/

/*Стандартный порт для "HTTP" это "80", а для "HTTPS" это "443".*/

/*В HTML5 был добавлена возможность добавлять "Web Workers". Их чаще всео используют для сложных
вычислений. "Web Workers" работают в фоновом режиме, не нарушая основной синхронный код. Можно
зарегистрировать не более 57 "Web Workers".*/

/*"IndexedDB" это база данных, работающая на стороне клиента и являющаяся более мощным инструментом,
чем "localStorage". "IndexedDB" предназначен для оффлайн-приложений. "IndexedDB" хранит информацию
в формате ключ-значение. "IndexedDB" основан на "Chrome". Эту БД можно использовать для больших
данных, транзакций, PWA-приложений. "IndexedDB" это встроенная в браузер БД. "IndexedDB"
является асинхронной БД, то есть данный из нее возвращаются в асинхронном потоке (возвращаются
промисы). "localStorage" является синхронным.*/

/*"GraphQL" это язык серверных запросов, более логичное продолжение "RestAPI". "RestAPI" у нас
есть "end points", на которые мы делаем запросы. А в "GraphQL" есть один умный "end-point", который
обрабатывает все запросы. В "GraphQL" GET-запрос именуется "Query", а остальные как запросы на мутирование
данных - "Mutate". В "GraphQL" имеется типизация.*/

/*Метод "eval()"" выполняет JavaScript-код, представленный строкой.*/

/*В "cookies" есть флаг "HTTPONLY", который нужен для того, чтобы не дать доступа к "cookies"
через "Document.cookie". Таким образом такой флаг защищает от XSS-атак.*/

/*Хоки позволяют меньше меньше кода, так как мы можем снабжать какими-то данными
много компонентов при помощи вызова одно и того же Хока.*/

/*Если функцию забайндили, то ее уже нельзя перебайндить.*/

/*-------------------------------------------------------------------------------------------------------------*/

/*Здесь временно "1" обварачивается в объект, затем у этого объекта вызывается метод "toString()", затем
объект-обвертка умирает.*/
console.log((1).toString());

let b = 1;
console.log(b.toString());

/*-------------------------------------------------------------------------------------------------------------*/

/*Если мы создаем какую-то функцию, внутри которой объявляется другая функция, то в 
памяти будет только один объект, связанный со внешней функцией, до тех пор пока, она не будет
вызвана.*/
function SomeFuncA () {
    this.a = function () {
        console.log('Do you see me?')
    };    
};

let c = new SomeFuncA();

console.log(SomeFuncA);
console.log(c);