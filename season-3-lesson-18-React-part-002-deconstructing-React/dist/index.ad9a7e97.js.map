{"mappings":"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","sources":["index.tsx"],"sourcesContent":["/*\r\n1. npm install typescript parcel -D\r\n\r\n2. добавить в package.json:\r\n\r\n\"scripts\": {\r\n   ...\r\n   \"tsc\": \"tsc\"\r\n},\r\n\r\n3. npm run tsc -- --init\r\n\r\n4. изменение tsconfig.json:\r\n\r\n...\r\n\"jsx\": \"react\",\r\n...\r\n\"strict\": false,\r\n...\r\n\r\n5. npx parcel index.html\r\n*/\r\n\r\n/*-------------------------------------------------------------------------------------------------------------*/\r\n\r\nlet React = {\r\n    /*Метод \"React.createElement()\" должен получать JSX и выдать наружу элемент для отрисовки. При запуске\r\n    приложения автоматически запускается с каждой переменной и функцией, указанно в коде. Переменные\r\n    преобразуются в объект, обозначающий React-элемент. функции преобразуются в объект, обозначающий \r\n    React-компонент, что в JSX мы указываем как тег, например \"<App />\".*/\r\n    createElement: (tag, props, ...children) => {\r\n        if (typeof tag === 'function') { /*Если на вход пришла функция, то есть компонент, то для нее нужна \r\n        отдельная обработка.*/\r\n            try { /*Если на входе функция, то попробуем ее вызвать, передав ей \"props\", а затем вернуть\r\n            наружу результат ее работы.*/\r\n                return tag(props);\r\n            } catch ({ promise, key }) { /*Если при вызове функции был возвращен промис, то попробуем \r\n            перехватить его. Точнее перехватить объект с двумя свойствами \"promise\" и \"key\", то есть объект, \r\n            который может быть создан функцией \"createResource()\" ниже. При перехватите такого объекта мы вернем \r\n            сразу же специально подготовленный React-элемент, сообщающий, что идет подгрузка каких-то данных, а\r\n            параллельно будет идти выполнение промиса, причем когда промис зарезольвиться мы установим данные\r\n            в коллекцию ключ/значение \"promiseCache\" и сделаем перериросовку, чтобы уже отрисовать наш компонент \r\n            \"App\" с полученными из промиса данными.*/\r\n                promise.then(data => {\r\n                    promiseCache.set(key, data);\r\n                    rerender();\r\n                });\r\n\r\n                return { tag: \"h1\", props: { children: [\"I AM LOADING\"] } };\r\n            };\r\n        };\r\n\r\n        /*Формируем объект, обозначающий React-элемент.*/\r\n        const element = { tag, props: { ...props, children } };\r\n        // console.log(element);\r\n\r\n        /*Возвращаем наружу сформированный React-элемент.*/\r\n        return element;\r\n    }\r\n};\r\n\r\n/*-------------------------------------------------------------------------------------------------------------*/\r\n\r\n/*Если использовать JSX, например, без React, то будет ошибка, говорящая о тому, что необходимо орпеделить React. \r\nПоэтому мы определили его выше. Но далее появится еще одна ошибка о том, что метод \"React.createElement()\" не \r\nопределена. Поэтому здесь мы также определяем и этот метод выше. Этот метод принимает три аргумента: тэг, props \r\nи дочерние элементы. В соответствии с этими аргументами можно вывести информацию о наших элементах JSX в \r\nконсоль и увидеть таким образом дерево нашего проекта. Примерно так и формируется виртуальный DOM - объект с \r\nдочерними элементами.\r\n\r\nПеременная \"abc\" это только лишь React-элемент, далее ниже мы уже создаем компонент \"App\".*/\r\nconst abc = <div className=\"react-2020\">\r\n    <h1>Hello, not a person!</h1>\r\n    <p>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Nesciunt ut quod tempore beatae! Vitae necessitatibus voluptatibus dicta rem repudiandae eligendi, aut doloribus omnis atque, quo aliquid libero in itaque accusamus.</p>\r\n</div>\r\n\r\n/*-------------------------------------------------------------------------------------------------------------*/\r\n\r\n/*Это наш \"state\".*/\r\nconst states = [];\r\n/*Наш \"state\" это массив, который содержится из как бы множества сдвигаемых частей, то есть каждый элемент\r\nмассива обозначает какую-то часть \"state\". Поэтому мы будем здесь использовать курсор, для перемещения по \r\n\"state\". Например, вызвав этот хук первый раз мы под первым эдементом массива сохраним имя пользователя и\r\nсдвигаем курсор на 1, затем вызвав второй раз этот хук мы уже под вторым элементом, так как курсор сдвинули,\r\nсохраним данные счетчика. Вызывая сеттеры этого хука мы курсор уже сдвигать не будем, что позволит хранить\r\nи изменять данные под одними и тем же курсорами.*/\r\nlet stateCursor = 0;\r\n\r\n/*Определяем хук \"useState\". Этот хук получает изначальный \"state\" и возвращает\r\nмассив, содержащий \"state\" и сеттер для этого значения.*/\r\nconst useState = (initialState) => {\r\n    /*Получаем текущий курсор \"state\" и сохраняем его отдельно для каждой новой части \"state\", чтобы какая-то \r\n    часть \"state\" и сеттер для изменения этой части \"state\" работали по одному и тому же курсору. Далее по \r\n    этому курсору в \"state\" сохраняем какие-то данные.*/\r\n    const FROZENCURSOR = stateCursor;\r\n    /*Если \"state\" по какому-то курсору уже существовал, то его и сохраняем, иначе сохраняем переданный\r\n    \"state\". Это нам нужно, чтобы после перерисовки компонента не сбрасывались значения \"state\".*/\r\n    states[FROZENCURSOR] = states[FROZENCURSOR] || initialState;\r\n\r\n    /*Сеттер получает новый \"state\", записывает его в текущий \"state\" по нужному курсору, и вызывает \r\n    перерисовку.*/\r\n    const setState = (newState) => {\r\n        states[FROZENCURSOR] = newState;\r\n        console.log(states);\r\n        rerender();\r\n    };\r\n\r\n    /*Записав данные по курсору в \"state\" и определив для этих данных сеттер, сдвигаем курсор вперед.*/\r\n    stateCursor++;\r\n\r\n    /*Возвращаем наружу \"state\" по определенному курсору и сеттер для изменения этой части \"state\"*/\r\n    return [states[FROZENCURSOR], setState];\r\n};\r\n\r\n/*-------------------------------------------------------------------------------------------------------------*/\r\n\r\nconst promiseCache = new Map();\r\n\r\n/*В React есть функция \"createResource()\", при помощи которой можно обвернуть промисы и создать ресурс на их\r\nоснове. Эта функция принимает два параметра - что-то, что возвращает промис, и уникальный ключ для данных, \r\nполученных в результате этого промиса. В этой функции мы должны отслеживать зарезольвился ли промис, то есть \r\nготовы ли данные. Для такого отслеживания мы создали коллекцию ключ/значение \"promiseCache\" выше.*/\r\nconst createResource = (thingThatReturnsASomething, key) => {\r\n    /*Если наш кэш промисов имеет указанный ключ, то мы возвращаем значение этого ключа.*/\r\n    if (promiseCache.has(key)) {\r\n        return promiseCache.get(key);\r\n    };\r\n\r\n    /*Если наш кэш промисов не имеет указанный ключ, то мы выкидываем объект, содержащий промис и ключ.\r\n    Для получения промиса мы вызываем переданную функцию.*/\r\n    throw { promise: thingThatReturnsASomething(), key };\r\n};\r\n\r\n/*-------------------------------------------------------------------------------------------------------------*/\r\n\r\n/*Здесь мы уже создаем React-компонент, поэтому используем функцию, а не переменную.*/\r\nconst App = () => {\r\n    /*Здесь мы используем хук \"useState\", который мы определили выше.*/\r\n    const [name, setName] = useState(\"person\");\r\n    const [count, setCount] = useState(0);\r\n\r\n    /*Далее пример использования хука в условии. В этом примере работа хука будет непредсказуема, поэтому\r\n    хуки в условиях не используются.*/\r\n    // let count = 451;\r\n    // let setCount = () => {};\r\n\r\n    // if (Math.random() > .5) {\r\n    //     [count, setCount] = useState(0);\r\n    // };\r\n\r\n    /*В React разрабатывается \"concurrent mode\" (конкурентный режим), который позволяет осуществлять \r\n    асинхронную отрисовку. В этом режим может приостанавливаться отрисовка компонента, если необходимо дождаться \r\n    завершения какой-то асинхронной операции, например, промиса или запроса. На данный момент это все еще \r\n    эскперементальный функционал.\r\n    \r\n    Здесь вызываем функцию \"createResource()\", передав функцию, которая делает запрос, во время которого\r\n    будет создан промис, что добавит асинхронности в наш код. Также вторым параметром для функции\r\n    \"createResource()\" мы указываем уникальный ключ для данных, которые будут получены, когда\r\n    промис зарезольвится.*/\r\n    const dogPhotoUrl = createResource(() => fetch('https://dog.ceo/api/breeds/image/random')\r\n        .then(r => r.json())\r\n        .then(payload => payload.message), \"dogPhoto\");\r\n\r\n    /*Компонент должен возвращать JSX.*/\r\n    return (\r\n        <div className=\"react-2020\">\r\n            <h1>Hello, {name}!</h1>\r\n            <input value={name} onchange={e => setName(e.target.value)} type=\"text\" placeholder=\"name\" />\r\n            <h2>The count is: {count}</h2>\r\n            <img alt=\"GOOD BOYEE\" src={dogPhotoUrl} />\r\n            <button onclick={() => setCount(count + 1)}>+</button>\r\n            <button onclick={() => setCount(count - 1)}>-</button>\r\n            <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Exercitationem voluptates porro consectetur assumenda architecto pariatur, mollitia dolore ipsa neque, natus et quis! Temporibus quos et ipsa tenetur. Ab, sapiente cupiditate?</p>\r\n        </div>\r\n    );\r\n};\r\n\r\n/*-------------------------------------------------------------------------------------------------------------*/\r\n\r\n/*Определим функцию, которая будет отвечать за отрисовку. Эта функция должна принимать React-элемент и контейнер,\r\nв котором нужно отрисовать этот React-элемент. Благодаря этой функции виртуальный DOM встраивается в обычный \r\nDOM.*/\r\nconst render = (reactElementOrStringOrNumber, container) => {\r\n    /*Помимпо React-элементов, в функцию отрисовки могут быть переданы строки и числа, например, в \r\n    качестве дочерних элементов в виде текста у HTML-элементов. Поэтому мы здесь проверяем, что\r\n    если переданный первый параметр имеет тип строки или числа, то мы переводи в строку этот\r\n    параметр, затем на его основе этого создаем новый текстовой узел, и в конце добавляем\r\n    этот узел в указанный контейнер. После этого завершаем отрисовку.*/\r\n    if ([\"string\", \"number\"].includes(typeof reactElementOrStringOrNumber)) {\r\n        container.appendChild(document.createTextNode(String(reactElementOrStringOrNumber)));\r\n\r\n        return;\r\n    };\r\n\r\n    /*Создаем в DOM новый HTML-элемент на основе тега, указанного в переданном React-элементе.*/\r\n    const actualDomElement = document.createElement(reactElementOrStringOrNumber.tag);\r\n\r\n    /*Если в переданном React-элементе указаны какие-либо \"props\", то мы берем их ключи,\r\n    берем из них те, которые не являются дочерними элементами, и затем для каждого из них\r\n    создаем атрибут для указанного React-элемента.*/\r\n    if (reactElementOrStringOrNumber.props) {\r\n        Object.keys(reactElementOrStringOrNumber.props)\r\n            .filter(p => p !== \"children\")\r\n            .forEach(p => actualDomElement[p] = reactElementOrStringOrNumber.props[p]);\r\n    };\r\n\r\n    /*Если в переданном React-элементе указаны какие-либо дочерние элементы, то мы рекурсивно\r\n    отрисовываем их внутри указанного React-элемента. Нужно обратить внимание здесь на то, что\r\n    контейнер в данном случае уже является сам HTML-элемент, соотвествующий переданному\r\n    React-элементу, чтобы была сохранена структура дерева виртуального DOM.*/\r\n    if (reactElementOrStringOrNumber.props.children) {\r\n        reactElementOrStringOrNumber.props.children.forEach(child => render(child, actualDomElement));\r\n    };\r\n\r\n    /*И в итоге добавляем наполненый HTML-элемент в DOM.*/\r\n    container.appendChild(actualDomElement);\r\n};\r\n\r\n/*Определим функцию для перерисовки. Для перерисовки мы удаляем первый дочерний элемент\r\nв контейнере, то есть наш компонент \"App\", и затем отрисовываем этот компонент заного. Также здесь\r\nмы сбрасываем курсор, так как если мы будем вызывать перерисовку компонента при использовании сеттеров \r\nиз хука \"useState\" и не будем сбрасывать курсор, то курсор постоянно будет сдвигаться дальше, так как\r\nпри отрисовке компонента мы каждый раз вызываем хук \"useState\", что может привести к тому, что, например,\r\nпри первой отрисовке имя пользователя сохранится под курсором \"0\", а данные счетчика под курсором \"1\",\r\nдалее при перерисовке имя пользователя сохранится под курсором \"2\", а данные счетчика под курсором \"3\",\r\nкогда нам нужно, чтобы каждая часть \"state\" оставалась под одним и тем же курсором.*/\r\nconst rerender = () => {\r\n    stateCursor = 0;\r\n    document.querySelector(\"#app\").firstChild.remove();\r\n    render(<App />, document.querySelector(\"#app\"));\r\n};\r\n\r\n/*Вызываем функию для отрисовки, передав ей компонет JSX и элемент, в котором нужно отрисовать нужный компонент.\r\nНа самом деле любой \"id\" в HTML-разметке это глобальный объект, поэтому вторым параметром можно было указать\r\n\"window.app\", но так лучше не делать.*/\r\nrender(<App />, document.querySelector(\"#app\"));\r\n\r\n/*React-элементы, которые не являются компонентами, тоже можно отрисовать, только не в виде тега.*/\r\n// render(abc, document.querySelector(\"#app\"));"],"names":[],"version":3,"file":"index.ad9a7e97.js.map","sourceRoot":"/__parcel_source_root/"}