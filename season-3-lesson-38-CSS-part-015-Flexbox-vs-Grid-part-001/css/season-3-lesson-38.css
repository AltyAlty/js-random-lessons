* {
    margin: 0;
    padding: 0;
}

/*-------------------------------------------------------------------------------------------------------------------*/

/*В этом примере у нас есть 10 элементов со свойством "flex-basis" равным 160px и способностью расти и сжиматься. Как
только в первой строке мы попадаем в то место, когда нет возможности поместить еще один элемент с размером 160px,
создается новая строка для этого элемента и так будет повторяться, пока не поместятся все элементы.Так как элементы
могут расти, то их размер станет больше, чем 160px в том случае, когда все строки полностью заполнятся. Если на
последней строке останется только один элемент, то он расширится до ширины всей строки.*/
.box {
    display: flex;
    flex-wrap: wrap;
    margin-bottom: 50px;
}

/*Селектор ".box>*" указывает, что будут выбраны все дочерние элементы элемента с классом "box".*/
.box > * {
    flex: 1 1 160px;
    border: 1px solid black;
}

/*-------------------------------------------------------------------------------------------------------------------*/

/*То же самое будет происходить с колонками. Содержащему контейнеру надо задать высоту, чтобы элементы начали
переноситься в следующую колонку. И высота элементов тоже будет увеличиваться, чтобы заполнить колонку по высоте
полностью.*/
.box-02 {
    height: 300px;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    margin-bottom: 50px;
}

.box-02 > * {
    flex: 1 1 80px;
    border: 1px solid black;
}

/*-------------------------------------------------------------------------------------------------------------------*/

.box-03 {
    display: flex;
    flex-wrap: wrap;
    flex-direction: row-reverse;
    margin-bottom: 50px;
}

.box-03 > * {
    flex: 1 1 160px;
    border: 1px solid black;
}

/*-------------------------------------------------------------------------------------------------------------------*/

/*Ключевое слово "auto-fill" может использоваться как значение при указании ширины колонок в CSS Grid. Это значение
может сказать браузеру, чтобы он уместил как можно больше колонок с учетом указанной длины. На данный момент единица fr
может использоваться только для максимального значения в функции "minmax()".*/

/*В технологии флексбоксов нет методов, которые позволили бы сказать элементам в одной строке выстроиться так же, как в
строке выше — каждая флекс-строка ведет себя как новый флекс-контейнер. Это так же касается распределения пространства
по главной оси. Если есть только один элемент и ему разрешено расти, то он будет расти и заполнять главную ось
направления, так же, как будто бы он был единственным элементов в контейнере.

Следующий живой пример использует технологию CSS Grid для создания макета с несколькими колонками, каждая из которых
имеет установленный минимальный размер в 160px и соответственно распределяя дополнительное пространство между всеми
столбцами. Однако в этом случае элементы остаются в своей сетке и не растягиваются, если их в последнем ряду меньше.

В этом разница между одно- и двух -мерной компоновкой. В одномерном методе, таком как Flexbox, мы контролируем только
одно измерение - либо строки, либо столбцы. В двумерном макете, таком как Grid, мы контролируем сразу оба измерения.
Если вы хотите распределение пространства построчно, используйте Flexbox. Если не хотите - используйте Grid.*/
.box-04 {
    /* width: 1800px; */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    /* grid-template-columns: repeat(10, minmax(160px, 1fr)); */
    border: 1px solid black;
    margin-bottom: 50px;
}

.box-04 > * {
    border: 1px solid black;
}

/*Ключевое слово "auto-fit" будет вести себя почти как "auto-fill", но если есть только одна строка и есть место для
дополнительных колонок, но нет элементов, которые можно вставить эти колонки, то тогда он сделает ширину пустых колонок
равную нулю. А если выставить максимальную ширину колонок на 1fr, то браузер разделит оставшееся место поровну между
ними.*/
.box-05 {
    /* width: 1800px; */
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    /* grid-template-columns: repeat(10, minmax(160px, 1fr)); */
    border: 1px solid black;
    margin-bottom: 50px;
}

.box-05 > * {
    border: 1px solid black;
}

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если вы назначите процентную ширину для flex элементов - либо задав значение параметру flex-basis, либо добавив ширину
к самому элементу, при этом оставив значение свойства "flex-basis" как "auto" - вы можете создать впечатление
двухмерного макета. Здесь мы установили свойства "flex-grow" и "flex-shrink" на 0, чтобы запретить flex элементам расти
и сжиматься, а затем контролируем их размер с помощью процентов, как это делают в макетах со свойством "float".

Если вам нужно, чтобы flex элементы выровнялись по поперечной оси, такой способ управления шириной позволит этого
добиться. Тем не менее, в большинстве случаев, добавление параметра ширины непосредственно в сам flex контейнер говорит
о том, что возможно будет лучше, если вы переключитесь на технологию Grid для этого компонента макета.*/
.box-06 {
    width: 500px;
    display: flex;
    flex-wrap: wrap;
    border: 1px solid black;
    margin-bottom: 50px;
}

.box-06 > * {
    flex: 0 0 33.3333%;
    /* border: 1px solid black; */
}

/*-------------------------------------------------------------------------------------------------------------------*/

/* На данный момент у нас нет никакого решения задачи создания промежутков между flex элементами flexbox, кроме как
использования средств Box Model. Попытки создать промежутки между элементами, при этом не создавая промежутки с
границами содержащего контейнера, приводят к тому, что нам приходится использовать отрицательные значения свойства
"margin" для самого контейнера. Любая граница в flex контейнере затем перемещается во вторую оболочку, чтобы
отрицательное поле могло вытянуть элементы до этого элемента оболочки.*/
.wrapper {
    border: 2px dotted rgb(96, 139, 168);
    width: 500px;
    margin-bottom: 50px;
}

.box-07 {
    border: 1px solid black;
    display: flex;
    flex-wrap: wrap;
    margin: -10px;
}

.box-07 > * {
    flex: 1 1 160px;
    margin: 10px;
    border: 1px solid black;
}

/*-------------------------------------------------------------------------------------------------------------------*/

/*В следующем примере у нас показан flex контейнер с параметром "перенос" в состоянии "не переносить". Третий элемент
имеет контента больше, чем другие элементы. И у него установлен параметр "visibility: collapse". Следовательно он имеет
некую "распорку", которая удерживает ту высоту, которая позволит показать этот элемент. Если вы удалите
"visibility: collapse" или измените значение на "visible", то вы увидите, что элемент появится, а пространство
перераспределится между не свернутыми элементами; высота flex контейнера при этом не изменится.*/
.box-08 {
    border: 1px solid black;
    display: flex;
    margin-bottom: 50px;
}

.box-08 > * {
    flex: 1 1 200px;
    border: 1px solid red;
}

.hide {
    visibility: collapse;
}

/*-------------------------------------------------------------------------------------------------------------------*/

/*Когда вы работаете с многострочным flex контейнером, вы должны помнить, что процесс обертывания происходит после
сворачивания. Таким образом, браузер должен повторно выполнить процедуру оборачивания, чтобы учесть новое пространство,
оставленное свернутым элементом в главной оси. Это значит, что элементы могут оказаться на строке, отличной от той, на
которой они начинались. В случае, если какой-то элемент отображается и скрывается, это может привести к тому, что
элементы окажутся в другом ряду.

Здесь вы можете увидеть, как растяжение меняет строку в зависимости от расположения свернутого элемента. Если вы
добавите больше контента ко второму элементу, он изменит строку, как только станет достаточно длинным. Эта верхняя
строка становится такой же высокой, как одна строка текста. Если это вызывает проблемы для вашего макета, возможно вам
стоит задуматься над переделкой структуры, например, поместить каждую строку в отдельный flex контейнер, чтобы они не
могли смещать строки.*/
.box-09 {
    border: 1px solid black;
    display: flex;
    flex-wrap: wrap;
    margin-bottom: 50px;
}

.box-09 > * {
    border: 1px solid red;
    flex: 1 1 auto;
}

.hide-02 {
    visibility: collapse;
}

/*Когда вы устанавливаете элементу правило "display: none" чтобы его спрятать, то этот элемент удаляется из структуры
страницы. На практике это означает, что счетчики игнорируют его, а такие вещи, как transitions (переходы), не
запускаются. Использование правила "visibility: hidden" сохраняет элемент в структуре форматирования, что полезно,
поскольку он по-прежнему ведет себя так, как если бы он был частью макета, даже если пользователь не может его
увидеть.*/