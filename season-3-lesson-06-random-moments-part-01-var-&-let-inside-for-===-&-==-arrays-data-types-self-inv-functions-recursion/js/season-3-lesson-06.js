/*В пустом объекте нет свойств кроме тех, которые находятся в прототипе.*/

/*-------------------------------------------------------------------------------------------------------------------*/

/*Здесь сначала очень быстро отработает цикл "for" и создаст очередь из 5 функций "setTimeout". Так как здесь 'i'
глобальная переменная, то в конце работы цикла ее значение будет равно '5'. Поэтому в итоге мы каждую секунду будем
выводить в консоль цифру '5'.*/
// for (var i = 0; i < 5; i++) {
//     setTimeout(function () {
//         console.log(i);
//     }, i * 1000);
// };

/*Здесь же 'i' локальная переменная, и в итоге мы каждую секунду будем выводить в консоль цифры '0', '1', '2', '3', '4'.
Так происходит, так как в любом замыкании созданном внутри цикла переменные 'let' будут связаны со значением каждой
итерации цикла, в то время как переменные 'var' будут текущим значением переменной, то есть каждая функция, выполняемая
в цикле, будет выполняться после завершения всего цикла, и поэтому все функции будут ссылаться на последнее значение,
хранящееся в 'i', которое будет равно '5'.*/
// for (let i = 0; i < 5; i++) {
//     setTimeout(function () {
//         console.log(i);
//     }, i * 1000);
// };

/*Но при использовании переменной 'var' внутри тела цикла можно использовать самовызывающуюся функцию. Тем самым мы
создадим уникальную область видимости для каждой итерации, в которой будет храниться уникальное значение переменной для
каждой такой области видимости.*/
// for (var i = 0; i < 5; i++) {
//     (function (x) {
//         setTimeout(function () {
//             console.log(x);
//         }, x * 1000);
//     })(i)
// };

/*-------------------------------------------------------------------------------------------------------------------*/

/*Оператор тройного равенства '===' возвращает значение 'true', если два выражения на любой из его сторон имеют один и
тот же тип и одинаковое значение. Однако оператор двойного равенства '==' пытается преобразовать значения перед их
сравнением. Поэтому обычно рекомендуется использовать '===', а не '=='. То же самое верно и для '!==' и '!='.*/
console.log(false == '0'); // true, string '0' is coerced to number '0'.
console.log(false === '0'); // false

/*-------------------------------------------------------------------------------------------------------------------*/

let someArrayOne = [1, 2, 3];
console.log(someArrayOne);
someArrayOne.push(4); // Так можно добавить элемент в начало массива.
someArrayOne.unshift(0); // Так можно добавить элемент в конец массива.
console.log(someArrayOne); // [0, 1, 2, 3, 4]

someArrayOne = [-1, ...someArrayOne]; // Или же в ES6 можно использовать оператор '...' ('spread' оператор).
someArrayOne = [...someArrayOne, 5];
console.log(someArrayOne); // [-1, 0, 1, 2, 3, 4, 5]

someArrayOne = [-2, ...someArrayOne, 6]; // Более краткая версия.
console.log(someArrayOne); // [-2, -1, 0, 1, 2, 3, 4, 5, 6]

/*-------------------------------------------------------------------------------------------------------------------*/

/*Число плюс строка = склеивание двух строк.*/
console.log(1 + '2' + '2'); // '122'. Первый плюс преобразует число "1" в строку.
console.log(1 + +'2' + '2'); // '32'. Плюс перед первой строкой "2" преобразует ее в число.
console.log(1 + -'1' + '2');  // '02'. Минус перед первой строкой "1" преобразует ее в число.
console.log(+'1' + '1' + '2'); // '112'. Число + строка + строка = строка
console.log('A' - 'B' + '2'); // 'NaN2'. Оператор "-" не может быть применен к строкам, и тем более 
// строки "A" и "B" не могут быть приведены к числам, то 'A' - 'B' даст "NaN".
// А "NaN" плюс строка дает склеивание двух строк.
console.log('A' - 'B' + 2); // NaN. Здесь опять 'A' - 'B' даст "NaN", но "NaN" плюс число дает снова "NaN".

/*-------------------------------------------------------------------------------------------------------------------*/

(function () {
    console.log(1);

    setTimeout(function () {
        console.log(2);
    }, 1000);

    setTimeout(function () {
        console.log(3);
    }, 0);

    console.log(4);
})(); // 1 => 4 => 3 => 2

/*-------------------------------------------------------------------------------------------------------------------*/

/*В данном случае идет переполнение стека вызовов из-за большого количества рекурсии. Но использование "setTimeout"
сделает так, чтобы "event loop" в итоге обрабатывал эти рекурсии, что в итоге не вызовет переполнение стека вызовов.*/

function createBigArray(arraySize) {
    let a = [];

    for (let i = 0; i < arraySize; i++) {
        a.push(i);
    };

    return a;
};

let reallyBigArray = createBigArray(30000);

function letsRecurseOne() {
    let item = reallyBigArray.pop();

    if (item) {
        console.log(item);

        setTimeout(letsRecurseOne, 0);
        // letsRecurseOne(); //  Uncaught InternalError: too much recursion
    };
};

letsRecurseOne();

/*-------------------------------------------------------------------------------------------------------------------*/

let aaa = "true" == true;
console.log(aaa); // false