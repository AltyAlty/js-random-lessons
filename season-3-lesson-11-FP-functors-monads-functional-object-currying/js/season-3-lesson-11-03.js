'use strict';

/*
В JS многие вычисления можно осуществлять разными способоми. Монаду можно считать
неким обобщенным способом вычисления.
*/

/*
Вот так условно выглядит императивное программирование:
a = f1();
b = f2(a);
c= f3(b);
*/

/*
Вот так условно выглядит функциональное программирование:
f3( f2( f1() ) );
*/

/*
Оба случая работают примерно так:
1. Выполняем первый шаг вычсиления.
2. Получаем результат первого шага.

3. Используем полученный результат для выполнения второго шага вычисления.
4. Выполняем второй шаг вычисления.
5. Получаем результат второго шага.

6. Используем полученный результат для выполнения третьего шага вычисления.
7. Выполняем третий шаг вычисления.
8. Получаем результат третьего шага.

То есть следующий результат зависит от предыдущего результата. А это то, что происходит
в монадах.
*/

/*-------------------------------------------------------------------------------------------------------------*/

/*
Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как 
"f(a, b, c)", а как "f(a)(b)(c)". Каррирование не вызывает функцию. Оно просто трансформирует её.
*/

function currySomeFunc(f) {
    return function (a) {
        return function (b) {
            return f(a, b);
        };
    };
};

function sumSomething(a, b) {
    return a + b;
};

/*Здесь вернется "function (a) {....." с сохранненой в лексическом окружении под локальной переменной "f" 
функция "sumSomething()".*/
let wrappedSumSomething = currySomeFunc(sumSomething);

/*А здесь мы сначала вызываем эту функцию "function (a) {....." с параметром "1". Вызов этой функции
вернет "function (b) {.....". Причем в лексическом окружении все еще хранится под локальной переменной "f" 
функция "sumSomething()" и к ней добавился локальный параметр "a" со значением "1". Далее мы вызываем
эту функцию "function (b) {....." с параметром "2", что возвращает вызов "f(a, b);", то есть 
"sumSomething(1, 2)".*/
console.log(wrappedSumSomething(1)(2)); // 3

/*
Ипользовать каррирование можно если обнаружится, что вы неоднократно вызываете одну и ту же функцию, передавая 
ей практически одни и те же параметры. Вы можете создать новую функцию, используя прием применения части 
параметров к оригинальной функции. Новая функция будет хранить повторяющиеся параметры (благодаря чему вам 
не придется передавать их каждый раз) и использовать их для заполнения полного списка аргументов, ожидаемых 
оригинальной функцией.
*/

/*Для более продвинутой реализации каррирования можно использовать метод "_.curry()" из библиотеки "lodash".*/