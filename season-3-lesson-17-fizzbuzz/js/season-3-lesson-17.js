/*Задача FizzBuzz: Дано 100 чисел, нужно вывести их на экран. Если число делится на 3, то нужно
вывести слово "Fizz", если на 5, то "Buzz", если на 3 и 5, то "FizzBuzz".*/

/*-------------------------------------------------------------------------------------------------------------*/

/*Решение 1: Структурное программирование. Такое программирование гласит, что любой алгоритм
может быть реализован при помощи 3-х управляемых конструкций:
1) Последовательность, которую нужно воспринимать как однократное выполнение операций в том
порядке, в котором они записаны в программе.
2) Ветвление.
3) Цикл.
Также в структурном программирование есть понятие блока. Один из принципов в структурном 
программировании гласит, что все логически связанные инструкции необходимо оформлять в виде
одного логического блока. В разных языках логические блоки отображаются по разному, например,
в JS это "{}". Так согласно одному из принципов структурного программирования отступы используются
для придания коду структуры, то есть код должно представлять из себя вложенную структуру, причем
на каждом уровне есть один вход и один выход и разработка должна идти пошагово сверху вниз.

Проблема данного решения, что такую программу сложно расширять и сопровождать, так как с появлением
новых требований код будет очень сильно разрастаться. Также здесь не соблюдается принцип DRY.*/

// for (let i = 0; i < 100; i++) {
//     if (i % 3 === 0 && i % 5 === 0) {
//         console.log(i + ' FizzBuzz 3 and 5');
//     } else if (i % 3 === 0) {
//         console.log(i + ' Fizz 3');
//     } else if (i % 5 === 0) {
//         console.log(i + ' Buzz 5');
//     } else {
//         console.log(i);
//     };
// };

/*-------------------------------------------------------------------------------------------------------------*/

/*Решение 2: Флаговое программирование. Здесь будут использоваться флаги и подпрограммы. Этот вариант немного
лучше первого. Здесь для каждого условия создана подпрограмма и каждая такая подпрограмма является флагом.
Флаг - это переменная, которая принимает значение "true" или "false" и свидетельствует о каком-то состоянии
системы или программы. Но в данном случае в виде флага у нас функции, что является допустимым. Первое и второе
решения являются императивными.

В данном решении читаемость программы лучше, чем в первом решении, так как условиями здесь являются
осмысленные названия подпрограмм. Также здесь повышена тестируемость программы, так как теперь можно
каждое из условий проверить отдельно. Но поддерживаемость кода все еще является проблемой, так как
при добавлении новых требование будет увеличиваться блок "switch/case". Также здесь все еще не соблюдается 
принцип DRY.

Основная претензия к флагам это то, что имеют место быть сложные композитные стейты, когда у нас есть много
флагов и возникают непокрытые состояния, то есть когда у нас есть несколько флагов и не все возможные варианты
их значений перебираются в коде, что может привести к тому, что один из флагов примет значение, которое не
предусмотрено в программе. При этом чем больше флагов, тем сложнее покрыть все их варианты. Также недостатком
является глобальный стейт и невозможность изменить флаг, так как место использования флага и место его 
опеределения как правило очень сильно разорваны.
*/

// function isFizzBuzz(n) {
//     if (n % 3 === 0 && n % 5 === 0) {
//         return true;
//     };

//     return false;
// };

// function isFizz(n) {
//     if (n % 3 === 0) {
//         return true;
//     };

//     return false;
// };

// function isBuzz(n) {
//     if (n % 5 === 0) {
//         return true;
//     };

//     return false;
// };

// for (let i = 0; i < 100; i++) {
//     /*Указывая здесь "true" в качестве параметра будет вызываться каждый цикл
//     каждая функция до тех пор, пока какая-то из них не выдаст "true", в таком
//     случае в блоке, где пройдет проверка "true === true" сработает указанный
//     в этом блоке код.*/
//     switch (true) {
//         case isFizzBuzz(i):
//             console.log(i + ' FizzBuzz 3 and 5')
//             break;
//         case isFizz(i):
//             console.log(i + ' Fizz 3')
//             break;
//         case isBuzz(i):
//             console.log(i + ' Buzz 5')
//             break;
//         default:
//             console.log(i);
//             break;
//     };
// };

/*-------------------------------------------------------------------------------------------------------------*/

/*Решение 3: Функциональное программирование. Это декларативный вариант. Здесь мы используем каррирование
в первой функции, то есть это частично заданная функция.

В данном случае кода меньше, но его сложнее понять.*/

// const gen = (n, w) => (num) => num % n === 0 ? w : '';
// const fizz = gen(3, 'Fizz');
// const buzz = gen(5, 'Buzz');

// /*"Array(99)" генерирует новый массив из 99 элементов со значениями "undefined".*/
// /*"[...Array(99).keys()]" вернет массив ключей указанного массива, то есть вернет новый массив 
// "[0, 1, ... , 97, 98]".*/
// /*"[...Array(99).keys()].map(i => i + 1)" вернет новый массив "[1, 2, ... , 98, 99]". Массив здесь
// создается так неудобно, чтобы показать декларативный подход, то есть не использовать структурный 
// подход и циклы.*/
// /*"console.log(fizz(i) + buzz(i) || i)" здесь если "fizz(i) + buzz(i)" будет равен
// пустой строке, что будет приведено к "false", то выведется в консоль "i", то есть то, что справа от "||".*/
// [...Array(99).keys()].map(i => i + 1).forEach(i => console.log(fizz(i) + buzz(i) || i));

/*-------------------------------------------------------------------------------------------------------------*/

/*Решение 4: ООП. Здесь для построения архитектуры программы в данном случае мы будем решать задачу
назначения тега или метки, то есть у нас есть какой-то входной набор данных и мы должны сопоставить этому
набору какую-то метку. Нам нужны следующие метки: по правилу деления на 3, по правилу деления на 5,
по правилу деления на 3 и 5. Архитектура построена по правилу слева направо, сверху вниз, то есть сущности,
которые находятся сверху и слева, используются сущностями, которые находятся правее и ниже. Таким образом
реализация в коде тоже будет идти слева направо и сврху вниз. Данное решение соотвествует SOLID.

Данное решение гораздо более многословнее, но зато выше поддерживаемость программы и ее тестирование.*/

/*Объектно ориентировная декомпозиция:
                       NUM                  TAG<-------PRINTER
                        /\                   |
                        |                    |
                        |                    |
                        |                   /\
                        |                   \/
CONDITION---------<>STRATEGY-------------<>RULE
                     |   /\                  |
                     |   \/                  |
                     |___|                  /\
                                            \/
                                        COLLECTION
*/

/*"TAG" это value object из ООП. У нас есть тег "TAG" и число "NUM". У нас есть правило назначения тегов "RULE",
здесь мы указываем его абстрактно без деталей, рассуждая категория интерфейсов, так как уже в самом коде
мы будем делать более точное именование классов. Рассуждая категориями интерфейсов позволяет создавать более
гибкие программы, так как потом их легче расширять благодаря этим интерфейсам. В нашем правиле "RULE" есть
какой-то тег "TAG". Далее нам нужно сопоставить "TAG" и "NUM". Исходя из условий задачи у нас 2 простых условия
и 1 составное условие, а наличие составного условия говорит о том, что у нас есть какая-то стратегия "STRATEGY",
так как вместо "И" может появиться логическое "ИЛИ". Поэтому мы используем здесь паттерн "стратегия". Получается,
что в "RULE" у нас есть какая-то стратегия определения меток для числа. В самой "STRATEGY" у нас есть условия:
деление на 3, на 5, на 3 и 5. Но можно предположить, что у нас могут появиться еще какие-то условия. Для этого
мы создаем отдельный интерфейс "CONDITION" для условий. И если у нас в будущем появится очень сложное правило,
то мы предусматриваем композицию стратегии саму на себя, то есть мы на вход стратегии сможем подавать новую
стратегию, тем самым получая новые стратегии. "STRATEGY" должна сопоставляться с "NUM". То есть у нас появляется
правило "RULE", у которого есть стратегия "STRATEGY", у которой в свою очередь есть условие "CONDITION", и
благодаря этому условию мы сопоставляем число "NUM" какой-то метке "TAG". Поскольку у нас есть несколько 
вариантов, то нам нужна коллекция "COLLECTION". Коллекция это очень часто встречаемый примитив в программировании.
Ну и на последок нам нужно выводить на экран результат, поэтому нам нужен элемент для вывода на экран "PRINTER".
Данная структура соотвествует принципу единственной отвественность из SOLID, так как у нас есть всегда только
одна причина для изменения каждого компонента этой структуры.*/

const MAX_NUM = 100;

class Tag /*Implements Value*/ {
    constructor(_value) {
        this.value = _value;
    };
};

class Printer {
    constructor(_context) {
        this.context = _context
    };

    print() {
        console.log(this.context.value);
    };
};

class DivCondition /*Implements Condition, Truthy*/ {
    constructor(_divider) {
        this.divider = _divider;
    };

    isTruthy(num) {
        return num % this.divider === 0;
    };
};

class AndStrategy /*Implements Strategy, Truthy*/ {
    constructor(_conditionsOrStrategies) {
        this.conditions = _conditionsOrStrategies;
    };

    isTruthy(num) {
        for (let i in this.conditions) {
            if (!this.conditions[i].isTruthy(num)) {
                return false;
            };
        };
        return true;
    };
};

class TagNumRule /*Implements Rule*/ {
    constructor(_tag, _strategy) {
        this.strategy = _strategy;
        this.tag = _tag;
    };

    isSuccess(num) {
        return this.strategy.isTruthy(num);
    };
};

class TagNumRulesCollection /*Implements Collection*/ {
    constructor(_tags) {
        this.tags = _tags;
    };

    find(num, defaultValue) {
        for (let i in this.tags) {
            if (this.tags[i].isSuccess(num)) {
                return this.tags[i].tag;
            };
        };
        return defaultValue;
    };
};

const numTags = new TagNumRulesCollection([
    new TagNumRule(new Tag('FizzBuzz'), new AndStrategy([new DivCondition(3), new DivCondition(5)])),
    new TagNumRule(new Tag('Fizz'), new AndStrategy([new DivCondition(3)])),
    new TagNumRule(new Tag('Buzz'), new AndStrategy([new DivCondition(5)]))
]);

for (let i = 0; i < MAX_NUM; i++) {
    new Printer(
        numTags.find(i, new Tag(i))
    ).print();
};