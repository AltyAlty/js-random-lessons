'use strict';

/*--------------------------------------------------------------------------------------------------------------------*/

/*Event Loop - это механизм среды выполнения (браузеры или Node.js), который управляет порядком выполнения кода.

В браузерах Event Loop реализуется движком, например, V8 в Chrome, вместе с Web APIs, например, DOM, функция
"setTimeout()" или функция "fetch()", и отвечает за выполнение JavaScript-кода, обработку событий и рендеринг.

В Node.js Event Loop имееет аналогичный механизм, но вместо Web APIs используются C++-биндинги, например, файловая
система или сетевые запросы.

Сам язык JavaScript не определяет Event Loop, он только лишь предоставляет однопоточную модель выполнения.

Как Event Loop работает в браузере:
1. Движок JavaScript выполняет синхронный код сразу через Call Stack.
2. Асинхронный код сначала регистрируется в Web APIs. Web APIs обрабатывают асинхронные операции, например, таймеры или
запросы, а их callback-функции попадают в:
    1) Очередь микрозадач.
    2) Очередь макрозадач.
3. Event Loop проверяет, пуст ли Call Stack, и если это так, то переносит callback-функции из очередей микрозадач и
макрозадач в Call Stack для их выполнения.
4. Рендеринг происходит между циклами Event Loop.

Call Stack - единственное место, где выполняется код (будь то синхронный или асинхронная callback-функция).*/

/*--------------------------------------------------------------------------------------------------------------------*/

/*Шаги работы Event Loop:

1. Фаза запуска скрипта. На этой фазе выполняется весь доступный синхронный код. Этот синхронный код выполняется только
один раз - при запуске скрипта. Но нужно всегда помнить, что выполнение этой фазы является также макрозадачей.

2. Фаза выполнения одной макрозадачи. Выполняется одна макрозадача из очереди макрозадач. Если это первый цикл, то эта
фаза выполняется в первом шагу.

3. Фаза выполнения всех микрозадач. Выполняются все доступные микрозадачи в очереди микрозадач. Если какая-то
микрозадача или макрозадача порождает другую микрозадачу, то эта другая микрозадача мгновенно переходит в очередь
микрозадач и выполняется в текущем цикле. Но браузер может ограничить глубину рекурсии для избежания бесконечных циклов
выполнения микрозадач.

Нужно помнить, что каждый вызов методов "then()" или "catch()" возвращает новый промис. Обработчики полученные в ходе
вызова методов "then()" или "catch()" не регистрируются все сразу, каждый ждет выполнения предыдущего. Каждый новый
обработчик добавляется в очередь микрозадач только после выполнения предыдущего.

4. Фаза выполнения callback-функций, указанных в функции "requestAnimationFrame()". Браузер регистрирует указанные
callback-функции в специальной очереди анимационных кадров, которая часто называется "animation frame queue" или
"rendering pipeline". Браузер ждет момента перед слудующей фазой - фазой рендеринга, параллельно синхронизируясь с
частотой обновления основного монитора, чтобы вызвать все указанные зарегистрированные callback-функции в основном
Call Stack-е. Если указанные callback-функции выполняются слишком долго, то браузер может пропустить кадр (dropped
frame), чтобы не задерживать рендеринг.

5. Фаза рендеринга. Эта фаза происходит не каждый цикл, а только когда браузер решит, что пора обновлять экран (обычно
60 раз в секунду), или когда есть изменения, требующие перерисовки. Эта фаза состоит из следующих шагов:
1) Layout - расчет или перерасчет геометрии макета страницы, то есть геометрии элементов на странице.
2) Paint - отрисовка пикселей на странице.
3) Composite - композиция нарисованных слоев в финальное изображение.

Layout - это процесс расчета размеров и позиций всех элементов на странице.
Браузер выполняет Layout, если:
- Изменился DOM, например, быд добавлен или удален элемент.
- Изменились стили, например, CSS-свойства "width", "height", "margin" или "font-size".
- Были запрошены геометрические данные, например, свойство "element.offsetHeight".
Иногда Layout синонимично называют Reflow, чтобы подчеркнуть перерасчет геометрии измененных элементов на странице.

Paint - это процесс отрисовки пикселей на экране для измененных областей без изменения макета.
Браузер выполняет Paint, если:
- Изменились стили, например, CSS-свойства "color", "background-color", background" или "box-shadow".
- Был осуществлен Layout/Reflow, то есть нужно отрисовать новые данные на основе измененной геометрии.
Иногда Paint синонимично называют Repaint, чтобы подчеркнуть что это перерисовка, а не первая отрисовка.

Composite - это процесс объединения заранее нарисованных слоев, например, элементов со CSS-свойствами "transform" или
"opacity", в одно финальное изображение, осуществляемый GPU. Браузер выполняет Composite всегда в конце фазы рендеринга,
но только для измененных слоев.

Браузер не всегда выполняет все этапы, он оптимизирует процесс рендеринга:
- Если изменения не затрагивают геометрию, например, были изменены только CSS-свойства "color", "background" или
"box-shadow", то Layout будет пропущен.
- Если изменения только для GPU, например, были изменены только CSS-свойства "transform", "opacity" или "filter", то
Layout и Paint будут пропущены.
- Если никакие свойства элементов не изменились, то фазы Layout, Paint и Composite будут пропущены.

Layout дороже Paint, а Paint дороже Composite, поэтому лучше:
- Группировать изменения DOM, например, через функцию "requestAnimationFrame()".
- Избегать чтение геометрии в циклах.
- Избегать чтения геометрии после ее изменения.
- Использовать CSS-свойства "transform" или "opacity" для анимаций.
- Использовать CSS-свойство "will-change" для анимаций, например, "will-change: transform", чтобы браузер заранее
создавал отдельные слои для ускорения Composite.

6. Если после фазы рендеринга осталось время, то срабатывает функция "requestIdleCallback()". Браузер стремится к 60
FPS, то есть на каждый кадр отводится ~16.6 мс. Если рендеринг занял, например, 10 мс, то остается ~6.6 мс простоя.
Именно в этот момент браузер проверяет очередь callback-функций, переданных функции "requestIdleCallback()". Если
пользователь начал взаимодействие со страницей, например клик или скролл, то браузер прерывает выполнение idle-задач и
возвращается к ним позже.

Функция "requestIdleCallback()" - это механизм в браузере, позволяющий выполнять фоновые задачи, когда основной поток
простаивает, то есть нет активных анимаций, обработки событий или других срочных задач.

Функция "requestIdleCallback()" - это API, которое:
- Ставит задачу в очередь, но выполняет ее только в периоды простоя.
- Гарантирует, что задача не помешает критически важным процессам, например, рендерингу, анимациям или вводу 
пользователя.
- В качестве параметра принимает callback-функцию, в которую передает объект "IdleDeadline", показывающий сколько
времени осталось до следующего кадра (максимум 50 мс, чтобы не блокировать основной поток надолго) при помощи вызова
метода "timeRemaining()" и не был ли прерван таймаут при помощи свойства "didTimeout".

7. На этом шаге текущий цикл заканчивается и начинается новый цикл, в котором повторяются шаги 2 - 7. Если очередь
макрозадач пустая (шаг 2), то браузер может "заснуть" до появления новых задач, например, событий мыши или таймеров.

Первый цикл Event Loop:
1. Выполнение макрозадачи в виде запуска скрипта и выполнения всего доступного синхронного кода.
2. Выполение всех доступных микрозадач.
3. Выполнение callback-функций, указанных в функции "requestAnimationFrame()".
4. Выполнение рендеринга: Layout -> Paint -> Composite.
5. Выполнение callback-функций, указанных в функции "requestIdleCallback()".

Остальные циклы Event Loop:
1. Выполнение одной макрозадачи.
2. Выполение всех доступных микрозадач.
3. Выполнение callback-функций, указанных в функции "requestAnimationFrame()".
4. Выполнение рендеринга: Layout -> Paint -> Composite.
5. Выполнение callback-функций, указанных в функции "requestIdleCallback()".*/

/*--------------------------------------------------------------------------------------------------------------------*/

/*Макрозадачи - это "тяжелые" асинхронные задачи, которые выполняются по одной за один цикл Event Loop.

Макрозадачи в браузере:
1. Таймеры, например:
    1) Callback-функции функции "setTimeout()".
    2) Callback-функции функции "setInterval()".

2. События DOM, например:
    1) Callback-функции вызываемые при срабатывании событий при взаимодействии со страницей, например, клики, скроллы
    или ввод текста.
    2) Callback-функции вызываемые при срабатывании событий во время загрузки ресурсов, например, успешная загрузка
    ресурсов ("onload") или ошибка при загрузке ресурсов ("onerror").

3. Сетевые запросы, например:
    1) Callback-функции функций "XMLHttpRequest()" или "fetch()".
    2) WebSocket-события ("onmessage", "onopen").

4. Рендеринг и анимации, например:
    1) Callback-функции функции "requestAnimationFrame()", но они выполняются перед рендерингом, а не как обычные
    макрозадачи.
    2) Callback-функции функции "requestIdleCallback()", но они выполняется в периоды простоя, а не как обычные
    макрозадачи.

5. Другие API:
    1) Callback-функции, связанные с изменением URL через свойство "history.pushState".
    2) Callback-функции, вызываемые при срабатывании события "message", которое возникает входе передачи сообщений между
    окнами или фреймами через свойство "postMessage" окна или фрейма, например, при использовании Web Workers.
    3) Callback-функции экзмепляра "IntersectionObserver", которые вызываются при пересечении элементов с viewport.*/

/*--------------------------------------------------------------------------------------------------------------------*/

/*Микрозадачи - это "быстрые" асинхронные  задачи, которые выполняются все сразу за один цикл Event Loop после текущего 
кода или после одной выполненной макрозадачи.

Микрозадачи в браузере:
1. Callback-функции промисов, например:
    1) Метода "Promise.then()".
    2) Метода "Promise.catch()".
    3) Метода "Promise.finally()".
2. Callback-функции функции "queueMicrotask()".
3. Callback-функции экземпляра "MutationObserver", вызываемы при отслеживании изменений DOM.*/

/*--------------------------------------------------------------------------------------------------------------------*/

/*"MutationObserver" - это встроенный API браузеров, который позволяет отслеживать изменения в DOM (структуре,
атрибутах, содержимом элементов) и реагировать на них асинхронно через callback-функции. Это современная замена
устаревшим "Mutation Events".

Как работает "MutationObserver":
1. Создается наблюдатель с указанием callback-функции для изменений.
2. Настраивается, какие изменения отслеживать (атрибуты, дочерние элементы и так далее).
3. Подключается к DOM-элементу.
4. При изменениях браузер асинхронно вызывает callback-функцию, передавая список изменений.*/

/*Пример использования "MutationObserver".*/
// const element = document.createElement('div');
// element.className = 'class001';

// /*1. Создаем наблюдатель.*/
// const observer = new MutationObserver(
//     (mutations) => {
//         mutations.forEach(
//             (mutation) => { console.log('Изменен атрибут:', mutation.attributeName) }
//         );
//     }
// );

// /*2. Настраиваем наблюдение за атрибутами элемента.*/
// observer.observe(
//     element,
//     {
//         /*Отслеживаем атрибуты.*/
//         attributes: true,
//         /*Отслеживаем только конкретные атрибуты.*/
//         attributeFilter: ['class', 'customAttribute']
//     }
// );

// /*3. Пример изменения (вызовет колбэк).*/
// element.setAttribute('customAttribute', '123');
// element.setAttribute('class', 'class002');

/*--------------------------------------------------------------------------------------------------------------------*/

/*Пример использования функции "IntersectionObserver".*/
// const element = document.createElement('div');
// element.className = 'class001';
// document.body.append(element);

// /*1. Создаем наблюдатель.*/
// const observer = new IntersectionObserver(
//     (entries) => {
//         entries.forEach(entry => {
//             console.log('Элемент в зоне видимости:', entry.isIntersecting);
//         });
//     }
// );

// /*2. Настраиваем наблюдение за элементjv.*/
// observer.observe(document.querySelector('.class001'));

/*--------------------------------------------------------------------------------------------------------------------*/

/*Функция "queueMicrotask()" позволяет напрямую добавить функцию в очередь микрозадач. Она работает аналогично вызову
"Promise.resolve().then()", но является более явным и удобным способом планирования микрозадач.

Зачем использовать функцию "queueMicrotask" вместо "Promise":
1.Более явный код. Функция "queueMicrotask()" четко указывает, что вы планируете именно микрозадачу, а не работу с
"Promise".
2. Избегание побочных эффектов "Promise". Вызов "Promise.resolve().then()"" может неожиданно сработать в цепочке
промисов, а функция "queueMicrotask()" - нет.
3. Лучшая производительность. В некоторых браузерах функция "queueMicrotask()" работает чуть быстрее, чем "Promise".*/

/*--------------------------------------------------------------------------------------------------------------------*/

/*Пример использования функции "requestIdleCallback()".*/

// let itemsLeft = 2000;

// function doBackgroundWork(deadline) {
//     console.log(deadline);
//     console.log(deadline.timeRemaining());
//     console.log(deadline.didTimeout);

//     /*Выполняем задачи, пока есть время.*/
//     while (deadline.timeRemaining() > 0) {
//         console.log('do a big task');
//         itemsLeft--;
//     };

//     /*Продолжим выполнять задачи в следующий простой.*/
//     if (itemsLeft > 0) {
//         requestIdleCallback(doBackgroundWork);
//     };
// };

// requestIdleCallback(doBackgroundWork);

/*--------------------------------------------------------------------------------------------------------------------*/

/*Почему функция "setTimeout()" работает хуже функции "requestAnimationFrame()":
1. У функции "setTimeout()" нет синхронизации с частотой кадров. Функция "setTimeout()" пытается выполниться как можно
быстрее, но не привязана к рендер-циклу браузера, что может приводить к дроблению кадров, например, 3 вызова за 1 кадр
или 0 вызовов за следующий. Из-за этого анимации могут дергаться или работает с переменной скоростью.

2. Браузер не оптимизирует функцию "setTimeout()". Даже если указать "setTimeout(fn, 16.6)" для 60 FPS, то таймеры в
JavaScript могут быть неточными, так как могут задерживаться из-за других задач.

3. Дополнительные накладные расходы при использовании функции "setTimeout()". Каждый вызов функции "setTimeout()"
создает новую задачу в очереди макрозадач, что увеличивает нагрузку на Event Loop.*/

/*Почему aункция "requestAnimationFrame()" работает плавно, даже если выполняется после макрозадач:
1. Синхронизация с рендер-циклом браузера:
    1) Функция "requestAnimationFrame()" не просто вызывается через N миллисекунд - она ждет момента, когда браузер
    готов рисовать кадр.
    2) Браузер группирует все callback-функции функции "requestAnimationFrame()" перед отрисовкой, минимизируя задержки.

2. Оптимизация браузером:
    1) Браузер осознанно выделяет время для функции "requestAnimationFrame()" перед рендерингом.
    2) Если callback-функции функции "requestAnimationFrame()" выполняются слишком долго, то браузер может:
        - Пропустить кадр, но следующий вызов функции "requestAnimationFrame()" будет синхронизирован с новым кадром.
        - Не блокировать UI, потому что вызов функции "requestAnimationFrame()" не мешает обработке событий в отличие от
        функции "setTimeout*(", которая может "застрять" в очереди.

3. Приоритизация:
    1) Функция "requestAnimationFrame()" имеет высокий приоритет в рендер-фазе, поэтому браузер старается выполнить ее
    до отрисовки.
    2) Функция "setTimeout()" - это просто макрозадача, которая конкурирует с другими задачами.*/

/*Наглядная разница в Event Loop использования функции "setTimeout()" и функции "requestAnimationFrame()".
1. Функция "setTimeout()":

[ Макрозадача 1 ] → [ Микрозадачи ] → [ Рендеринг ] → [ Макрозадача 2 (setTimeout) ] → ...

Функция "setTimeout()" может выполниться после рендеринга, когда кадр уже отрисован, что будет означать, что изменения
применились с опозданием.

2. Функция "requestAnimationFrame()":

[ Макрозадачи ] → [ Микрозадачи ] → [ requestAnimationFrame ] → [ Рендеринг ] → ...

Функция "requestAnimationFrame" выполняется перед рендерингом, что означает, что изменения сразу попадают на экран.*/

/*Важные нюансы:
1. Функция "requestAnimationFrame()" и функция "setTimeout(fn, 0)":
    1) Функция "setTimeout(fn, 0)" попадает в очередь макрозадач и выполняется после рендеринга, если Event Loop до него
    вообще дойдет.
    2) Функция "requestAnimationFrame()" выполняется перед рендерингом и синхронизирована с частотой обновления экрана.

2. Функция "requestAnimationFrame()" и Web Workers:
    1) Функцию "requestAnimationFrame()" нельзя вызывать внутри Web Worker, потому что она привязана к рендерингу DOM, а
    Web Workers не имеют доступа к DOM.
    2) Если нужно считать что-то сложное без блокировки рендеринга, то можно вынести вычисления в Web Worker, а
    результаты передавать в функцию "requestAnimationFrame()" через метод "postMessage()" окна или фрейма.

3. Функция "requestAnimationFrame()" в фоновых вкладках:
    1) В некоторых браузерах функция "requestAnimationFrame()" замедляется до 1 FPS в фоновых вкладках, например, чтобы
    экономить батарею.
    2) Если нужно, чтобы анимация работала в фоне, то можно использовать функцию "setTimeout()", но не рекомендуется.*/

/*Почему функция "requestAnimationFrame()" не тормозит, если он после микрозадач:
1. Микрозадачи выполняются мгновенно после текущего синхронного кода.
2. Макрозадачи могут задерживаться, но функция "requestAnimationFrame()" имеет специальный слот в рендер-фазе.
3. Браузер не ждет завершения всех макрозадач перед функцией "requestAnimationFrame()" - он просто старается уложиться в 
один кадр (~16.6 мс для 60 Гц).*/

/*--------------------------------------------------------------------------------------------------------------------*/

/*Каждый Web Worker имеет свой собственный Event Loop, полностью независимый от основного потока, а это означает, что:
1. У каждого Web Worker есть свой Call Stack, свои очереди микрозадач и макрозадач.
2. Общение между Web Workers и основным потоком происходит через асинхронные сообщения при помощи метода 
"postMessage()", которые попадают в очереди макрозадач обоих потоков.

Event Loop в Web Workers полностью идентичен основному потоку, но не имеет доступа к DOM, при этом имя свои API, 
например, метод "fetch()" или WebSocket.*/

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);
// requestAnimationFrame(() => { console.log(3) });
// Promise.resolve().then(() => { console.log(4) });
// console.log(5);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);

// new Promise((resolve) => {
//     console.log(3);
//     resolve();
// })
//     .then(() => { console.log(4) });

// setTimeout(() => { console.log(5) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);

// new Promise((resolve) => {
//     console.log(3);
//     resolve();
// })
//     .then(() => { console.log(4) })
//     .then(() => { console.log(5) });

// setTimeout(() => { console.log(6) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);

// const promise001 = new Promise((resolve) => {
//     console.log(3);
//     resolve();
// })
//     .then(() => { console.log(4) })

// promise001.then(() => { console.log(5) });
// setTimeout(() => { console.log(6) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);

// new Promise((resolve) => {
//     console.log(3);
//     resolve();
// })
//     .then(() => {
//         console.log(4);
//         throw new Error('');
//     })
//     .then(() => { console.log(5) })
//     .catch(() => { console.log(6) })

// setTimeout(() => { console.log(7) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);

// new Promise((resolve) => {
//     console.log(3);
//     resolve();
// })
//     .then(() => { console.log(4) })
//     .then(() => { console.log(5) });

// new Promise((resolve) => {
//     console.log(6);
//     resolve();
// })
//     .then(() => { console.log(7) })
//     .then(() => { console.log(8) });

// setTimeout(() => { console.log(9) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);

// new Promise((resolve) => {
//     console.log(2);
//     resolve();
// })
//     .then(() => {
//         console.log(3);
//         setTimeout(() => { console.log(4) }, 0);
//     })
//     .then(() => { console.log(5) });

/*--------------------------------------------------------------------------------------------------------------------*/

// setTimeout(() => { console.log(1) }, 0);

// setTimeout(
//     () => {
//         new Promise((resolve) => {
//             console.log(2);
//             resolve();
//         })
//             .then(() => { console.log(3) });
//     }, 0
// );

// new Promise((resolve) => {
//     console.log(4);
//     resolve();
// })
//     .then(() => { console.log(5) });

// setTimeout(() => { console.log(6) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);
// Promise.resolve().then(() => { console.log(3) });
// console.log(4);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);
// setTimeout(() => { console.log(2) }, 0);

// Promise.resolve().then(() => {
//     console.log(3);
//     Promise.resolve().then(() => { console.log(4) });
//     setTimeout(() => { console.log(5) }, 0);
// });

// console.log(6);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);

// setTimeout(
//     () => {
//         console.log(2);
//         queueMicrotask(() => { console.log(3) });
//     }, 0
// );

// queueMicrotask(() => {
//     console.log(4);
//     setTimeout(() => { console.log(5) }, 0);
//     queueMicrotask(() => { console.log(6) });
// });

// console.log(7);

/*--------------------------------------------------------------------------------------------------------------------*/

// console.log(1);

// setTimeout(
//     () => {
//         console.log(2);
//         queueMicrotask(() => { console.log(3) });
//     }, 0
// );

// Promise.resolve().then(() => { console.log(4) });
// requestAnimationFrame(() => { console.log(5) });

/*--------------------------------------------------------------------------------------------------------------------*/

// setTimeout(() => { console.log(1) }, 0);

// setTimeout(
//     () => {
//         console.log(2);

//         new Promise((resolve) => {
//             console.log(3);
//             resolve();
//         })
//             .then(() => { console.log(4) });

//         console.log(5);
//     }, 0
// );

// new Promise((resolve) => {
//     console.log(6);
//     resolve();
// })
//     .then(() => { console.log(7) });

// setTimeout(() => { console.log(8) }, 0);

/*--------------------------------------------------------------------------------------------------------------------*/

// let a = 0;

// for (let i = 0; i < 5; i++) {
//     a++;
//     console.log(i);

//     if (a > 3) {
//         new Promise((resolve) => {
//             console.log('aaa');
//             resolve();
//         })
//             .then(() => { console.log('bbb') });
//     };
// };

/*--------------------------------------------------------------------------------------------------------------------*/

// let a = 0;

// function func01() {
//     a++;

//     if (a > 3) {
//         new Promise((resolve) => {
//             console.log('aaa');
//             resolve();
//         })
//             .then(() => { console.log('bbb') });
//     };
// };

// for (let i = 0; i < 5; i++) {
//     console.log(i);
//     func01();
// };

/*--------------------------------------------------------------------------------------------------------------------*/

// let a = 100;

// async function bigFor() {
//     console.log('bigFor');
//     for (let index = 0; index < 5; index++) { console.log(index) };
//     return 4;
// };

// function one() { console.log('one') };

// async function two() {
//     console.log('two');

//     a = await bigFor();
//     // await bigFor().then((value) => { a = value; });

//     // a = bigFor();
//     // a.then((value) => { console.log(value); });

//     console.log(a);
// };

// function three() {
//     console.log('three');
//     console.log(a);
// };

// one();
// two();
// three();