/*Эта функция возвращает другую функцию.*/
function functionReturningAnotherFunction(a, b) {
    return function () {
        return 5;
    };
};

/*Вызов этой функции, вернет объект, содержащий другую функцию. Если вызвать полученную функцию, то уже получим "5".*/
let resultOne = functionReturningAnotherFunction(2, 4);
console.log(resultOne); // function () { return 5 }
console.log(resultOne()); // 5

/*Чтобы сразу получить "5", то есть вызвать первую функцию, а затем сразу вызвать функцию, которая будет возвращена
первой функцией, нужно вызвать первую функцию два раза, как показано ниже.*/
console.log(functionReturningAnotherFunction(2, 4)()); // 5

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если мы вызываем функцию, которая была возвращена какой-то другой функцией, то возвращеная функция будет хранить
контекст этой какой-то другой функции. То есть в данном случае в строке, где происходит деление, "a" будет найдено из
контекста верхней функции.*/
function divideOne(a) {
    return function (b) {
        return a / b;
    };
};

console.log(divideOne(4)(2)); // 2

/*-------------------------------------------------------------------------------------------------------------------*/

/*Здесь мы переписали предыдущую функцию при помощи синтаксиса стрелочных функций.*/
const divideTwo = a => b => a / b;

console.log(divideTwo(4)(2)); // 2

/*-------------------------------------------------------------------------------------------------------------------*/

/*Далее указаны два немного разных синтаксиса самовызывающихся функций.*/
(function () {
    console.log('I have been summoned!');
})();

(function () {
    console.log('I have been summoned too!');
}());

/*-------------------------------------------------------------------------------------------------------------------*/

/*Создали функцию, которая возвращает объект. Этот объект в свою очередь хранит в себе свойство, содержащее другую
функцию. То есть каждый раз вызывая функцию "createCounter()", мы будем создавать отдельный объект, что в итоге нам
будет позволять создавать счетчики независимые друг от друга, так как и контексты, где находиться "a", для каждого
объекта будут создаваться тоже отдельные.*/
function createCounter() {
    let a = 1;

    return {
        count: function () {
            return console.log(a++);
        }
    };
};

let counterOne = createCounter();
let counterTwo = createCounter();

counterOne.count(); // 1
counterOne.count(); // 2
counterOne.count(); // 3
counterOne.count(); // 4

counterTwo.count(); // 1
counterTwo.count(); // 2

/*-------------------------------------------------------------------------------------------------------------------*/

/*Можно создавать новые функции при помощи конструктора "Function". Параметрами указываются параметры функции, но
последним параметром указывается само тело функции.*/
const divideThree = new Function('a', 'b', 'return a / b');
console.log(divideThree(4, 2)); // 2

/*Это синтаксис стрелочных функций. Здесь стрелка указывает на то, что будет возвращено. Если параметр всего один, то
здесь можно не указывать его в скобках.*/
const divideFour = (a, b) => a / b;
console.log(divideFour(4, 2)); // 2

/*В этой функции мы используем "switch/case".*/
const divideFive = (a, b) => {
    let result;

    switch (b) {
        case (0):
            result = 'nope';
            break;

        default:
            result = a / b;
            break;
    };

    return result;
};
console.log(divideFive(0, 0)); // "nope"
console.log(divideFive(0, 2)); // 0
console.log(divideFive(4, 0)); // "nope"
console.log(divideFive(4, 2)); // 2

/*В этой функции используется тернарный оператор.*/
const divideSix = (a, b) => a === 0 ? 'nope' : a / b;
console.log(divideSix(4, 2));

/*-------------------------------------------------------------------------------------------------------------------*/

/*Для выполнения математических действий можно использовать объект "Math".*/
const sqrtOne = a => Math.sqrt(a);
console.log(sqrtOne(36)); // 6

/*-------------------------------------------------------------------------------------------------------------------*/

/*Это функция возведения в степень числа при помощи цикла "for".*/
const expOne = (a, b) => {
    let result = 1;

    for (let i = 0; i < b; i++) {
        result *= a;
        // result = result * a;
    };

    return result;
};
console.log(expOne(2, 4)); // 16

/*А здесь функция возведения в степень числа, работающая при помощи рекурсии.
1. Вызывается функция "expTwo()" первый раз с параметрами 2 и 4.
2. Внутри этого первого вызова первый блок "if" пропускается и происходит второй вызов функции с параметрами 2 и 3.
3. Во втором вызове функции опять первый блок "if" пропускается и происходит третий вызов функции с параметрами 2 и 2.
4. В третьем вызове функции опять первый блок "if" пропускается и происходит четвертый вызов функции с параметрами 2 и
1.
5. В четвертом вызове функции опять первый блок "if" пропускается и происходит пятый вызов функции с параметрами 2 и 0.

6. В пятом вызове функции первый блок "if" уже не пропускается и пятый вызов функции возращает четвертому вызову функции
значение 1, после чего пятый вызов функции завершает свою работу.

7. Четвертый вызов функции получает это значение 1 и сохраняет его свою локальную переменную "previousValue", а далее
возвращает третьему вызову функции значение 1 * 2 = 2, после чего четвертый вызов функции завершает свою работу.
8. Третий вызов функции получает это значение 2 и сохраняет его свою локальную переменную "previousValue", а далее
возвращает второму вызову функции значение 2 * 2 = 4, после чего третий вызов функции завершает свою работу.
9. Второй вызов функции получает это значение 4 и сохраняет его свою локальную переменную "previousValue", а далее
возвращает первому вызову функции значение 4 * 2 = 8, после чего второй вызов функции завершает свою работу.
10. Первый вызов функции получает это значение 8 и сохраняет его свою локальную переменную "previousValue", а далее
возвращает "наружу" значение 8 * 2 = 16, после чего первый вызов функции завершает свою работу.*/
function expTwo(a, b) {
    /*Это базовый случай.*/
    if (b === 0) {
        return 1;
    };

    /*Это рекурсивный случай.*/
    let previousValue = this.expTwo(a, b - 1);

    return previousValue * a;
};
console.log(expTwo(2, 4)); // 16

/*Еще один вариант функции возведения в степень числа, работающей при помощи рекурсии и тернарного оператора.*/
function expThree(a, b) {
    return b === 0 ? 1 : this.expThree(a, b - 1) * a;
};
console.log(expThree(2, 4)); // 16

/*Еще один вариант функции возведения в степень числа, работающей при помощи оператора возведения в степень "**".*/
const expFour = (a, b) => a ** b;
console.log(expFour(2, 4)); // 16