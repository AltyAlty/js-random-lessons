/*Если в конструкторе был указан какой-то метод, то объекты, созданные при помощи этого конструктора, скопируют в себя
всю реализацию этого метода. При большом количестве объектов это может быть лишним, так как несколько объектов будут
содержать повторяющийся код. Любая функция в JS имеет свойство "prototype". Это свойство обычно используется с
функциями-конструкторами. Чтобы избежать ситуацию, описанную в начале, методы конструктора нужно отдельно указывать 
при помощи этого свойства "prototype". В таком случае у созданных объектов уже не будет методов их конструктора, но 
эти объекты смогут пользоваться этими метода, используя их из объекта-прототипа функции-конструктора благодаря 
прототипному наследование. То есть полученные объекты будут иметь ссылку на объект-прототип функции-конструктора.*/
function Car(name) {
    this.name = name;
    this.isTurnedOn = false;
    this.speed = 0;

    this.engine = {
        v: 1,
        horses: 100,
        isTurnedOn: false
    };
};

Car.prototype.start = function () {
    this.isTurnedOn = true;
    this.speed = 50;
    this.engine.isTurnedOn = true;
    console.log(this.name + ' ' + this.speed);
};

var car1 = new Car('kek');
var car2 = new Car('lol');
car1.start(); // kek 50
console.log(car1); // { ... speed: 50 }
console.log(car2); // { ... speed: 0 }
car2.start(); // lol 50
console.log(car1); // { ... speed: 50 }
console.log(car2); // { ... speed: 50 }

console.log('--------------------------------------------------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если в конструкторе не указать какое-то свойство и метод, в котором это свойство создается или изменияется, а в
объекте-прототип указать как метод, так и это свойство, то после создания объекта на основе этого конструктора этот 
созданный объект не будет иметь этого свойства, но это свойство будет в объекте-прототипе. И если затем попытаться 
прочитать это свойство у созданного объекта, например, при помощи "console.log()", то внутри этого созданного объекта 
это свойство найдено не будет, но будет найдено в объекте-прототипе. А дальше если вызвать упомянутый ранее метод от 
лица этого созданного объекта, то уже будет создано новое свойство для этого объекта.*/
function Car2(name) {
    this.name = name;
};

Car2.prototype.speed = 0;

Car2.prototype.changeSpeed = function () {
    this.speed = 5;
};

var car3 = new Car2('lel');

console.log(car3.speed); /*0, берется из объекта-прототипа.*/
console.log(car3); // { name: "lel" }

car3.changeSpeed(); /*Поскольку в контексте объекта "car3" нет свойства "speed", то оно там будет создано.*/

console.log(car3.speed); /*5, берется уже из объекта поскольку в контексте объекта "car3" уже есть свойство "speed".*/
console.log(car3); // { name: "lel", speed: 5 }

console.log('--------------------------------------------------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

/*Если в функции-конструкторе не указать какое-то свойство и метод, в котором это свойство создается или изменяется в 
виде объекта, а в объекте-прототипе указать как метод, так и это свойство, то после создания объекта на основе этой 
функции-конструктора этот созданный объект не будет иметь этого свойства, но это свойство будет в объекте-прототипе. И 
если затем попытаться прочитать это свойство у созданного объекта, например, при помощи "console.log()", то внутри 
этого созданного объекта свойство найдено не будет, но будет найдено в объекте-прототипе. А дальше если вызвать 
упомянутый ранее метод от лица созданного объекта, то не будет создано нового свойство в созданном объекте, а будет 
изменено свойство в объекте-прототипе. Так происходит потому, что объекты это ссылочные типы данных, и потому, что все
созданные объекты при помощи какой-то функции-конструктора ссылаются на один и тот же объект-прототип своей 
функции-конструктора. Исходя из этого лучше избегать указывать свойства в прототипах, лучше делать такое только для 
методов.*/
function Car3(name) {
    this.name = name;
};

Car3.prototype.engine = {
    speed: 10
};

Car3.prototype.changeSpeed = function () {
    this.engine.speed = 20;
    console.log(this.engine.speed);
};

var car4 = new Car3('kuk');
console.log(car4.engine.speed); /*10, из  объекта-прототипа.*/
console.log(car4); // { name: "kuk" }
car4.changeSpeed(); /*20, изменилось значение в  объекте-прототипе.*/
console.log(car4); // { name: "kuk" }
console.log(Car3.prototype.engine.speed); // 20

var car5 = new Car3('lal');
console.log(car5.engine.speed); /*20, из  объекта-прототипа.*/
console.log(car5);  // { name: "lal" }
car5.changeSpeed(); /*20, снова изменилось значение в  объекте-прототипе.*/
console.log(car5);  // { name: "lal" }

console.log('--------------------------------------------------------------------------------');

/*-------------------------------------------------------------------------------------------------------------------*/

function Garage(name) {
    this.name = name;
};

Garage.prototype.cars = [];

var garage1 = new Garage('first');
var garage2 = new Garage('second');

/*Но если в последнем случае не менять внутренности данных ссылочного типа в объекте-прототипе, а сделать 
переопределение, то  объект-прототип не изменится, а создастся новое свойство в созданном объекте.*/
console.log(garage1); // { name: "first" }
garage1.cars = [1, 2, 3];
console.log(garage1); // Есть свойство "cars" равное [1, 2, 3]
console.log(' ');

console.log(garage2); // { name: "second" }
console.log(garage2.cars); // [] из  объекта-прототипа
console.log(Garage.prototype.cars); // В "prototype" класса свойство "cars" равно []
console.log(garage2.cars === Garage.prototype.cars); // true
console.log(' ');

/*Хотя если опять попробуем все-таки изменить внутренности данных ссылочного типа в прототипе, то снова изменим сам
прототип.*/
garage2.cars.push(4);
console.log(garage1); // Есть свойство "cars" равное [1, 2, 3]
console.log(garage2); // Свойства "cars" нет
console.log(garage2.cars); // [4] из  объекта-прототипа
console.log(Garage.prototype.cars); // В "prototype" класса свойство "cars" равно [4]
console.log(' ');

garage1.cars.push(5);
console.log(garage1); // Есть свойство "cars" равное [1, 2, 3, 5]
garage2.cars.push(5);
console.log(garage2.cars); // [4, 5] из  объекта-прототипа
console.log(Garage.prototype.cars); // В "prototype" класса свойство "cars" равно [4, 5]
console.log(' ');

/*Из стрелочных функций нельзя делать конструкторы.*/

/*Если мы ищем какое-то свойство в объекте, его не находим, идем в  объект-прототип, там его находим и сразу пытаемся 
сделать set-операцию, то нам это не будет это разрешено, а будет выполнена эта set-операция в самом объекте. 

Если же мы ищем какое-то свойство в объекте, его не находим, идем в  объект-прототип, там его находим и дальше ищем 
какое-то еще другое более вложенное свойство, и если мы его находим и пытаемся сделать set-операцию, то эта операция 
будет проведена в  объекте-прототипе.*/
garage2.cars.quantity = 2;
console.log(garage2); // Object { name: "second" }
console.log(Garage.prototype.cars); // В "prototype" "cars" имеет свойство "quantity" равное 2
console.log(' ');

garage2.cars = 10;
console.log(garage2); // { name: "second", cars: 10 }
console.log(Garage.prototype.cars); // [4, 5]
console.log(' ');

garage2.mechanics = 4;
console.log(garage2); // { name: "second", cars: 10, mechanics: 4 }

/*-------------------------------------------------------------------------------------------------------------------*/

function Obj() {
    this.age = 25;
    this.name = 'Kek';
};

Obj.prototype.head = { brain: 1 };
Obj.prototype.stomach = ['food', 10];
Obj.prototype.shoes = { poorOnes: 2 };

let objTwo = new Obj();
let objThree = new Obj();

/*Здесь изменения произошли в  объекте-прототипе. Свойство "head" было найдено в  объекте-прототипе, значение которого 
ссылалось на объект "{ brain: 1 }". Мы поменяли в этом объекте значение свойства "brain", но ссылка осталась на этот 
же объект.*/
objTwo.head.brain = 2;

console.log(objTwo.head.brain); // 2 из  объекта-прототипа, так как ссылка на объект в свойстве "head" не изменилась.
console.log(objThree.head.brain); // 2 из  объекта-прототипа по той же причине.

/*Здесь изменения произошли в объекте "objTwo". Здесь мы устанавливаем новое свойство "stomach" в месте, которое уже
существует, то есть в объекте "objTwo". Нет необходимости обращаться к  объекту-прототипу.*/
objTwo.stomach = [];

console.log(objTwo);
console.log(objThree);
console.log(objTwo.stomach.length); // 0 из объекта "objTwo"
console.log(objThree.stomach.length); // 2 из  объекта-прототипа